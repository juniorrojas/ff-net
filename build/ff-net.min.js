!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).ffnet=e()}(this,(function(){"use strict";const t={createElement:function(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}};var e=t;class s{constructor(t,e,s,r){null==r&&(r=1),this.r=t,this.g=e,this.b=s,this.a=r}blend(t,e){if(Math.abs(e)>1)throw new Error("t must be a number between -1 and 1");let r,i;return e>=0?(r=this,i=t):(r=t,i=this),new s(r.r*(1-e)+i.r*e,r.g*(1-e)+i.g*e,r.b*(1-e)+i.b*e)}toString(){return`rgba(${Math.floor(255*this.r)}, ${Math.floor(255*this.g)}, ${Math.floor(255*this.b)}, ${this.a})`}}s.white=new s(1,1,1),s.black=new s(0,0,0),s.red=new s(226/255,86/255,86/255),s.blue=new s(135/255,173/255,236/255),s.lightBlue=new s(186/255,224/255,251/255),s.lightRed=new s(252/255,163/255,163/255);var r=s;var i=class{constructor(t,s,r,i){if(this.neuralNet=t,this.n0=s,this.nf=r,this.n0.group.id+1!=this.nf.group.id)throw new Error("Cannot connect neurons from non-consecutive groups");this.weight=null==i?1:i,this.weightGrad=0;const n=t.headless;if(this.headless=n,!n){const t=e;this.svgElement=t.createElement("path"),this.render()}}render(){const t=r,e=this.svgElement,s=this.n0.getPosition(),i=this.nf.getPosition();e.setAttribute("d","M"+s.x+" "+s.y+" L"+i.x+" "+i.y);const n=9*Math.min(1,Math.abs(this.weight)/5);let o;e.setAttribute("stroke-width",n),o=this.weight<0?t.red:t.blue,e.setAttribute("stroke-opacity",.4),e.setAttribute("stroke",o)}zeroGrad(){this.weightGrad=0}backward(t={}){this.weightGrad+=this.n0.activation*this.nf.preActivationGrad}forwardRegularization(t={}){return(t.regularization??0)*this.weight*this.weight*.5}backwardRegularization(t={}){const e=t.regularization??0;this.weightGrad+=e*this.weight}optimStep(t){if(null==t)throw new Error("lr required");this.weight-=t*this.weightGrad}toData(){const t={};return t.n0=[this.n0.group.id,this.n0.id],t.nf=[this.nf.group.id,this.nf.id],t.weight=this.weight,t}static fromData(t,e){const s=e.weight,r=e.n0,i=e.nf,n=t.neuronGroups[r[0]].neurons[r[1]],o=t.neuronGroups[i[0]].neurons[i[1]];return t.addLink(n,o,s)}};function n(t){return 1/(1+Math.exp(-t))}var o=class{constructor(t,s,r){this.group=t,this.id=s,this.outputLinks=[],this.inputLinks=[],this.bias=r,this.preActivation=0,this.activation=n(this.bias),this.activationGrad=0,this.preActivationGrad=0,this.biasGrad=0;const i=t.parent.headless;if(this.headless=i,!i){const t=e;(this.svgElement=t.createElement("circle")).setAttribute("r",12)}}forward(){this.preActivation=0,this.preActivation+=this.bias,this.inputLinks.forEach((t=>{this.preActivation+=t.weight*t.n0.activation})),this.activation=n(this.preActivation)}backward(t={}){this.outputLinks.forEach((t=>{this.activationGrad+=t.weight*t.nf.preActivationGrad})),this.preActivationGrad+=function(t,e){const s=n(t);return s*(1-s)*e}(this.preActivation,this.activationGrad),this.biasGrad+=this.preActivationGrad}optimStep(t){if(null==t)throw new Error("lr required");this.bias-=t*this.biasGrad}render(){const t=r,e=this.svgElement,s=this.getPosition();e.setAttribute("cx",s.x),e.setAttribute("cy",s.y);let i;if(0==this.inputLinks.length)i=t.blue.blend(t.red,.6);else{const e=3;const s=.5+Math.max(Math.min(this.bias,e),-e)/e*.5;i=t.red.blend(t.blue,s)}const n=i.blend(t.black,.3);e.setAttribute("fill",i.toString()),e.setAttribute("stroke",n.toString()),e.setAttribute("stroke-width",2)}getPosition(){const t=this.group.parent,e=this.group.numNeurons(),s=t.numNeuronGroups(),r=t.maxNumNeuronsPerGroup,i=t.width,n=t.height,o=n/2,a=(i-28)/(s-1),h=(n-28)/(r-1),u=i/2+(this.group.id-(s-1)/2)*a;let l;return l=0==e?o:o+(this.id-(e-1)/2)*h,{x:u,y:l}}zeroGrad(){this.activationGrad=0,this.preActivationGrad=0,this.biasGrad=0}toData(){return{bias:this.bias}}static fromData(t,e){t.addNeuron(e.bias)}};const a=o;var h=class{constructor(t,e){this.parent=t,this.id=e,this.neurons=[],this.headless=t.headless}render(){this.neurons.forEach((t=>{t.render()}))}addNeuron(t){const e=this.parent;null==t&&(t=.5);const s=this.numNeurons(),r=new a(this,s,t);return this.neurons.push(r),e.neurons.push(r),this.headless||e.svgNeurons.appendChild(r.svgElement),this.numNeurons()>e.maxNumNeuronsPerGroup&&(e.maxNumNeuronsPerGroup=this.numNeurons()),r}numNeurons(){return this.neurons.length}setActivations(t){const e=this.numNeurons();if(t.length!=e)throw new Error(`expected ${e} values, found ${t.length}`);for(let s=0;s<e;s++)this.neurons[s].activation=t[s]}getActivations(){return this.neurons.map((t=>t.activation))}toData(){return{neurons:this.neurons.map((t=>t.toData()))}}static fromData(t,e){const s=t.addNeuronGroup();e.neurons.forEach((t=>{a.fromData(s,t)}))}};class u{constructor(t){this.layer=t}*[Symbol.iterator](){const t=this.layer.outputNeuronGroup.neurons;for(let e=0;e<t.length;e++){const s=t[e];for(let t=0;t<s.inputLinks.length;t++)yield s.inputLinks[t]}}}const l=i,d=h,c=class{constructor(t={}){if(null==t.inputNeuronGroup)throw new Error("inputNeuronGroup required to create layer");if(null==t.outputNeuronGroup)throw new Error("outputNeuronGroup required to create layer");this.inputNeuronGroup=t.inputNeuronGroup,this.outputNeuronGroup=t.outputNeuronGroup,this.links=new u(this)}backward(t={}){this.outputNeuronGroup.neurons.forEach((e=>{e.backward(t)}));for(let e of this.links)e.backward(t)}getBiasArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((e=>{t.push(e.bias)})),t}getBiasGradArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((e=>{t.push(e.biasGrad)})),t}setBiasFromArray(t){const e=this.outputNeuronGroup.neurons;if(t.length!=e.length)throw new Error(`invalid bias size, found ${t.length}, expected ${e.length}`);e.forEach(((e,s)=>{e.bias=t[s]}))}getWeightArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((e=>{const s=[];t.push(s),e.inputLinks.forEach((t=>{s.push(t.weight)}))})),t}getWeightGradArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((e=>{const s=[];t.push(s),e.inputLinks.forEach((t=>{s.push(t.weightGrad)}))})),t}setWeightFromArray(t){this.inputNeuronGroup.neurons.forEach(((e,s)=>{e.outputLinks.forEach(((e,r)=>{e.weight=t[r][s]}))}))}};class p{constructor(t={}){this.neurons=[],this.links=[],this.neuronGroups=[],this.layers=[],this.maxNumNeuronsPerGroup=0;let s=t.headless??!0;const r=t.createDomElement??!1;if(r&&(s=!1),this.headless=s,!s){const s=e;if(this.svgElement=s.createElement("g"),this.svgLinks=s.createElement("g"),this.svgElement.appendChild(this.svgLinks),this.svgNeurons=s.createElement("g"),this.svgElement.appendChild(this.svgNeurons),r){const t=s.createElement("svg");t.appendChild(this.svgElement),this.domElement=t}const i=t.width??300,n=t.height??100;this.setRenderSize(i,n)}}setRenderSize(t,e){if(this.width=t,this.height=e,null!=this.domElement){const s=this.domElement;s.style.width=t,s.style.height=e}}clear(){if(!this.headless){for(;null!=this.svgLinks.firstChild;)this.svgLinks.removeChild(this.svgLinks.firstChild);for(;null!=this.svgNeurons.firstChild;)this.svgNeurons.removeChild(this.svgNeurons.firstChild)}this.links=[],this.neuronGroups=[],this.layers=[],this.neurons=[],this.maxNumNeuronsPerGroup=0}numNeuronGroups(){return this.neuronGroups.length}numLayers(){return this.layers.length}numNeurons(){return this.neurons.length}numLinks(){return this.links.length}getInputNeuronGroup(){if(0==this.neuronGroups.length)throw new Error("no neuron groups available");return this.neuronGroups[0]}getOutputNeuronGroup(){if(0==this.neuronGroups.length)throw new Error("no neuron groups available");return this.neuronGroups[this.neuronGroups.length-1]}addNeuronGroup(t){null==t&&(t=0);const e=this.numNeuronGroups(),s=new d(this,e);this.neuronGroups.push(s);for(let e=0;e<t;e++)s.addNeuron();return s}addFullyConnectedLayer(t){if(0==this.neuronGroups.length)throw new Error("cannot add fully connected layer if no neuron groups exist");if(null==t)throw new Error("number of output neurons required to create fully connected layer");const e=this.getOutputNeuronGroup();this.addNeuronGroup(t);const s=this.getOutputNeuronGroup();e.neurons.forEach((t=>{s.neurons.forEach((e=>{this.addLink(t,e)}))}));const r=new c({inputNeuronGroup:e,outputNeuronGroup:s});return this.layers.push(r),r}addLink(t,e,s){const r=new l(this,t,e,s);return t.outputLinks.push(r),e.inputLinks.push(r),this.links.push(r),this.headless||this.svgLinks.appendChild(r.svgElement),r}zeroGrad(){this.neurons.forEach((t=>{t.zeroGrad()})),this.links.forEach((t=>{t.zeroGrad()}))}randomizeParameters(){this.links.forEach((t=>{let e=2+4*Math.random();Math.random()<=.5&&(e*=-1),t.weight=e})),this.neurons.forEach((t=>{let e=1+2*Math.random();Math.random()<=.5&&(e*=-1),t.bias=e}))}forward(t){if(null!=t){const e=this.getInputNeuronGroup(),s=e.neurons;if(t.length!=s.length)throw new Error(`invalid input size, expected ${e.length}, found ${t.length}`);s.forEach(((e,s)=>{e.activation=t[s]}))}for(let t=1;t<this.neuronGroups.length;t++){this.neuronGroups[t].neurons.forEach((t=>{t.forward()}))}if(null!=t){return this.getOutputNeuronGroup().neurons.map((t=>t.activation))}}backward(t={}){for(let e=this.numLayers()-1;e>=0;e--){this.layers[e].backward(t)}}forwardData(t,e,s){const r=e-this.forward(t);return s.d=r,.5*r*r}backwardData(t){this.getOutputNeuronGroup().neurons[0].activationGrad=-t.d,this.backward()}forwardRegularization(t={}){const e=t.regularization??0;let s=0;return this.links.forEach((t=>{const r=t.weight;s+=.5*e*r*r})),s}backwardRegularization(t={}){this.links.forEach((e=>{e.backwardRegularization(t)}))}optimStep(t){if(null==t)throw new Error("lr required");this.links.forEach((e=>{e.optimStep(t)}));for(let e=1;e<this.neuronGroups.length;e++){this.neuronGroups[e].neurons.forEach((e=>{e.optimStep(t)}))}}train(t){const e=t.dataPoints;if(null==e)throw new Error("dataPoints required");const s=t.lr;if(null==s)throw new Error("lr required");const r=t.regularization??0,i=t.iters??1;let n,o;for(let t=0;t<i;t++)o=0,e.forEach((t=>{const e=[t.x,t.y],r=t.label,i={};o+=this.forwardData(e,r,i),this.zeroGrad(),this.backwardData(i),this.optimStep(s)})),n=this.forwardRegularization({regularization:r}),this.zeroGrad(),this.backwardRegularization({regularization:r}),this.optimStep(s);return{dataLoss:o,regularizationLoss:n}}render(){this.neuronGroups.forEach((t=>t.render())),this.links.forEach((t=>t.render()))}toData(){return{neuronGroups:this.neuronGroups.map((t=>t.toData())),links:this.links.map((t=>t.toData()))}}loadData(t){this.clear(),t.neuronGroups.forEach((t=>{d.fromData(this,t)}));for(let t=1;t<this.numNeuronGroups();t++){const e=this.neuronGroups[t-1],s=this.neuronGroups[t],r=new c({inputNeuronGroup:e,outputNeuronGroup:s});this.layers.push(r)}t.links.forEach((t=>{l.fromData(this,t)}))}static fromData(t,e={}){if(null==t)throw new Error("data required");const s=new p(e);return s.loadData(t),s}}var g={Sequential:p};const f=r;var m=class{constructor(t,e,s,r){this.canvas=t,this.x=e,this.y=s,this.label=r,this.radius=5}render(){const t=this.canvas.ctx,e=this.canvas.domElement.width,s=this.canvas.domElement.height;let r;r=0==this.label?f.red:f.blue;const i=r.blend(f.black,.6);t.beginPath(),t.fillStyle=r.toString(),t.strokeStyle=i.toString(),t.arc(this.x*e,this.y*s,this.radius,0,2*Math.PI),t.fill(),t.stroke()}toData(){return{x:this.x,y:this.y,label:this.label}}};const w=r,v=m,E=class{constructor(t){this.canvas=t,this._onDragBegin=this.onDragBegin.bind(this),t.addEventListener("mousedown",this._onDragBegin,{passive:!1}),t.addEventListener("touchstart",this._onDragBegin,{passive:!1}),this._onDragProgress=this.onDragProgress.bind(this),t.addEventListener("mousemove",this._onDragProgress,{passive:!1}),t.addEventListener("touchmove",this._onDragProgress,{passive:!1}),this._onDragEnd=this.onDragEnd.bind(this),window.addEventListener("mouseup",this._onDragEnd),window.addEventListener("touchend",this._onDragEnd),window.addEventListener("touchcancel",this._onDragEnd)}computeCursor(t){const e=this.canvas.getBoundingClientRect();let s,r;null==t.touches?(s=t.clientX,r=t.clientY):(s=t.touches[0].clientX,r=t.touches[0].clientY);const i={x:s-e.left,y:r-e.top};t.cursor=i}onDragBegin(t){t.preventDefault(),this.computeCursor(t),this.processDragBegin(t)}onDragProgress(t){null!=this.dragState&&(t.preventDefault(),this.computeCursor(t),this.processDragProgress(t))}onDragEnd(t){this.dragState=null}dragging(){return null!=this.dragState}};class G{constructor(t={}){if(!(this.headless=t.headless??!1)){const e=this.domElement=document.createElement("canvas");e.width=t.domWidth??250,e.height=t.domHeight??250;const s=e.getContext("2d",{willReadFrequently:!0});this.ctx=s,this.dragBehavior=new E(e),this.dragBehavior.processDragBegin=this.processDragBegin.bind(this),this.dragBehavior.processDragProgress=this.processDragProgress.bind(this)}this.dataWidth=t.dataWidth??50,this.dataHeight=t.dataHeight??50,this.dataPoints=[],this.clearPixels(),this.xyToPixel=(t,e)=>.5}clearPixels(){this.pixels=[];for(let t=0;t<this.dataWidth;t++){this.pixels.push([]);for(let e=0;e<this.dataHeight;e++)this.pixels[t].push(0)}}updatePixels(){const t=this.dataWidth,e=this.dataHeight;for(let s=0;s<t;s++)for(let r=0;r<e;r++){const i=this.xyToPixel(s/(t-1),r/(e-1));if(i<0||i>1)throw new Error(`pixel value must be between 0 and 1, found ${i}`);this.pixels[s][r]=i}}flushPixels(){const t=this.domElement,e=this.ctx,s=t.width,r=t.height,i=s/this.dataWidth,n=r/this.dataHeight;e.clearRect(0,0,s,r);const o=e.getImageData(0,0,s,r),a=o.data.length/4;for(let t=0;t<a;t++){const e=t%s,r=Math.floor(t/s),a=Math.floor(e/i),h=Math.floor(r/n),u=this.pixels[a][h],l=w.lightRed.blend(w.lightBlue,u),d=4*t;o.data[d]=Math.round(255*l.r),o.data[d+1]=Math.round(255*l.g),o.data[d+2]=Math.round(255*l.b),o.data[d+3]=255}e.putImageData(o,0,0)}addDataPoint(t,e,s){const r=new v(this,t,e,s);return this.dataPoints.push(r),r}clear(){this.dataPoints=[]}render(){this.updatePixels(),this.flushPixels(),this.dataPoints.forEach((t=>t.render()))}processDragBegin(t){for(let e=0;e<this.dataPoints.length;e++){const s=this.dataPoints[e],r=t.cursor.x-s.x*this.domElement.width,i=t.cursor.y-s.y*this.domElement.height,n=1.5*s.radius;if(r*r+i*i<=n*n){const t=this.dragBehavior.dragState={};t.dataPoint=s,t.offset={x:r,y:i};break}}}processDragProgress(t){const e=this.dragBehavior.dragState.dataPoint,s=this.dragBehavior.dragState.offset;e.x=(t.cursor.x-s.x)/this.domElement.width,e.y=(t.cursor.y-s.y)/this.domElement.height,e.x<0?e.x=0:e.x>1&&(e.x=1),e.y<0?e.y=0:e.y>1&&(e.y=1)}toData(){return this.dataPoints.map((t=>t.toData()))}loadFromData(t){this.dataPoints=[],t.forEach((t=>{this.addDataPoint(t.x,t.y,t.label)}))}static fromData(t){const e=new G;return e.loadFromData(t),e}}var b=G;var k={DataCanvas:b,LossPlot:class{constructor(t={}){const e=t.width??500,s=t.height??100,r=this.domElement=document.createElement("canvas");r.width=e,r.height=s,this.ctx=r.getContext("2d"),this.maxDataLength=e,this.data=[],this.minTopLoss=t.minTopLoss??4,this.topLoss=this.minTopLoss}push(t){this.data.length==this.maxDataLength&&this.data.shift(),this.data.push({totalLoss:t});const e=this.data.map((t=>t.totalLoss)),s=Math.max.apply(null,e);s>this.minTopLoss?this.topLoss=s:this.topLoss=this.minTopLoss,this.render()}render(){const t=this.ctx,e=this.domElement.width,s=this.domElement.height;t.clearRect(0,0,e,s),this.data.forEach(((r,i)=>{const n=r.totalLoss,o=i/(this.maxDataLength-1)*e,a=s*(1-n/this.topLoss);t.beginPath(),t.strokeStyle="rgb(255, 221, 78)",t.lineWidth=2,t.moveTo(o,s),t.lineTo(o,a),t.stroke()}))}clear(){this.data=[]}}};return{common:{Color:r,svg:e},nn:g,ui:k,Sequential:g.Sequential,DataCanvas:k.DataCanvas}}));
