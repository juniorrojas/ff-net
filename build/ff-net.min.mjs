<<<<<<< HEAD
const t={createElement:function(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}};var s=t;class r{constructor(t,s,r,e){null==e&&(e=1),this.r=t,this.g=s,this.b=r,this.a=e}blend(t,s){if(Math.abs(s)>1)throw new Error("t must be a number between -1 and 1");let e,i;return s>=0?(e=this,i=t):(e=t,i=this),new r(e.r*(1-s)+i.r*s,e.g*(1-s)+i.g*s,e.b*(1-s)+i.b*s)}toString(){return`rgba(${Math.floor(255*this.r)}, ${Math.floor(255*this.g)}, ${Math.floor(255*this.b)}, ${this.a})`}}r.white=new r(1,1,1),r.black=new r(0,0,0),r.red=new r(226/255,86/255,86/255),r.blue=new r(135/255,173/255,236/255),r.lightBlue=new r(186/255,224/255,251/255),r.lightRed=new r(252/255,163/255,163/255);var e=r;var i=class{constructor(t,r,e,i){if(this.neuralNet=t,this.n0=r,this.nf=e,this.n0.group.id+1!=this.nf.group.id)throw new Error("Cannot connect neurons from non-consecutive groups");this.weight=null==i?1:i,this.weightGrad=0;const n=t.headless;if(this.headless=n,!n){const t=s;this.svgElement=t.createElement("path"),this.render()}}render(){const t=e,s=this.svgElement,r=this.n0.getPosition(),i=this.nf.getPosition();s.setAttribute("d","M"+r.x+" "+r.y+" L"+i.x+" "+i.y);const n=9*Math.min(1,Math.abs(this.weight)/5);let o;s.setAttribute("stroke-width",n),o=this.weight<0?t.red:t.blue,s.setAttribute("stroke-opacity",.4),s.setAttribute("stroke",o)}zeroGrad(){this.weightGrad=0}backward(t={}){const s=this.n0.activation,r=this.nf.preActivationGrad;this.n0.activationGrad+=r*this.weight,this.weightGrad+=r*s}forwardRegularization(t={}){return(t.regularization??0)*this.weight*this.weight*.5}backwardRegularization(t={}){const s=t.regularization??0;this.weightGrad+=s*this.weight}optimStep(t){if(null==t)throw new Error("lr required");this.weight-=t*this.weightGrad}toData(){const t={};return t.n0=[this.n0.group.id,this.n0.id],t.nf=[this.nf.group.id,this.nf.id],t.weight=this.weight,t}static fromData(t,s){const r=s.weight,e=s.n0,i=s.nf,n=t.neuronGroups[e[0]].neurons[e[1]],o=t.neuronGroups[i[0]].neurons[i[1]];return t.addLink(n,o,r)}};function n(t){return 1/(1+Math.exp(-t))}var o=class{constructor(t,r,e){this.group=t,this.id=r,this.outputLinks=[],this.inputLinks=[],this.bias=e,this.preActivation=0,this.activation=n(this.bias),this.activationGrad=0,this.preActivationGrad=0,this.biasGrad=0;const i=t.parent.headless;if(this.headless=i,!i){const t=s;(this.svgElement=t.createElement("circle")).setAttribute("r",12)}}forward(){this.preActivation=0,this.preActivation+=this.bias,this.inputLinks.forEach((t=>{this.preActivation+=t.weight*t.n0.activation})),this.activation=n(this.preActivation)}backward(t={}){this.preActivationGrad+=function(t,s){const r=n(t);return r*(1-r)*s}(this.preActivation,this.activationGrad),this.biasGrad+=this.preActivationGrad}optimStep(t){if(null==t)throw new Error("lr required");this.bias-=t*this.biasGrad}render(){const t=e,s=this.svgElement,r=this.getPosition();s.setAttribute("cx",r.x),s.setAttribute("cy",r.y);let i;if(0==this.inputLinks.length)i=t.blue.blend(t.red,.6);else{const s=3;const r=.5+Math.max(Math.min(this.bias,s),-s)/s*.5;i=t.red.blend(t.blue,r)}const n=i.blend(t.black,.3);s.setAttribute("fill",i.toString()),s.setAttribute("stroke",n.toString()),s.setAttribute("stroke-width",2)}getPosition(){const t=this.group.parent,s=this.group.numNeurons(),r=t.numNeuronGroups(),e=t.maxNumNeuronsPerGroup,i=t.width,n=t.height,o=n/2,a=(i-28)/(r-1),h=(n-28)/(e-1),u=i/2+(this.group.id-(r-1)/2)*a;let l;return l=0==s?o:o+(this.id-(s-1)/2)*h,{x:u,y:l}}zeroGrad(){this.activationGrad=0,this.preActivationGrad=0,this.biasGrad=0}toData(){return{bias:this.bias}}static fromData(t,s){t.addNeuron(s.bias)}};const a=o;var h=class{constructor(t,s){this.parent=t,this.id=s,this.neurons=[],this.headless=t.headless}numNeurons(){return this.neurons.length}addNeuron(t){const s=this.parent;null==t&&(t=.5);const r=this.numNeurons(),e=new a(this,r,t);return this.neurons.push(e),s.neurons.push(e),this.headless||s.svgNeurons.appendChild(e.svgElement),this.numNeurons()>s.maxNumNeuronsPerGroup&&(s.maxNumNeuronsPerGroup=this.numNeurons()),e}setActivations(t){const s=this.numNeurons();if(t.length!=s)throw new Error(`expected ${s} values, found ${t.length}`);for(let r=0;r<s;r++)this.neurons[r].activation=t[r]}getActivations(){return this.neurons.map((t=>t.activation))}forward(){this.neurons.forEach((t=>{t.forward()}))}render(){this.neurons.forEach((t=>{t.render()}))}toData(){return{neurons:this.neurons.map((t=>t.toData()))}}static fromData(t,s){const r=t.addNeuronGroup();s.neurons.forEach((t=>{a.fromData(r,t)}))}};class u{constructor(t){this.layer=t}*[Symbol.iterator](){const t=this.layer.outputNeuronGroup.neurons;for(let s=0;s<t.length;s++){const r=t[s];for(let t=0;t<r.inputLinks.length;t++)yield r.inputLinks[t]}}}const l=i,d=h,c=class{constructor(t={}){if(null==t.inputNeuronGroup)throw new Error("inputNeuronGroup required to create layer");if(null==t.outputNeuronGroup)throw new Error("outputNeuronGroup required to create layer");this.inputNeuronGroup=t.inputNeuronGroup,this.outputNeuronGroup=t.outputNeuronGroup,this.links=new u(this)}backward(t={}){this.outputNeuronGroup.neurons.forEach((s=>{s.backward(t)}));for(let s of this.links)s.backward(t)}getBiasArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{t.push(s.bias)})),t}getBiasGradArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{t.push(s.biasGrad)})),t}setBiasFromArray(t){const s=this.outputNeuronGroup.neurons;if(t.length!=s.length)throw new Error(`invalid bias size, found ${t.length}, expected ${s.length}`);s.forEach(((s,r)=>{s.bias=t[r]}))}getWeightArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{const r=[];t.push(r),s.inputLinks.forEach((t=>{r.push(t.weight)}))})),t}getWeightGradArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{const r=[];t.push(r),s.inputLinks.forEach((t=>{r.push(t.weightGrad)}))})),t}setWeightFromArray(t){this.inputNeuronGroup.neurons.forEach(((s,r)=>{s.outputLinks.forEach(((s,e)=>{s.weight=t[e][r]}))}))}};class g{constructor(t={}){this.neurons=[],this.links=[],this.neuronGroups=[],this.layers=[],this.maxNumNeuronsPerGroup=0;let r=t.headless??!0;const e=t.createDomElement??!1;if(e&&(r=!1),this.headless=r,!r){const r=s;if(this.svgElement=r.createElement("g"),this.svgLinks=r.createElement("g"),this.svgElement.appendChild(this.svgLinks),this.svgNeurons=r.createElement("g"),this.svgElement.appendChild(this.svgNeurons),e){const t=r.createElement("svg");t.appendChild(this.svgElement),this.domElement=t}const i=t.width??300,n=t.height??100;this.setRenderSize(i,n)}}setRenderSize(t,s){if(this.width=t,this.height=s,null!=this.domElement){const r=this.domElement;r.style.width=t,r.style.height=s}}clear(){if(!this.headless){for(;null!=this.svgLinks.firstChild;)this.svgLinks.removeChild(this.svgLinks.firstChild);for(;null!=this.svgNeurons.firstChild;)this.svgNeurons.removeChild(this.svgNeurons.firstChild)}this.links=[],this.neuronGroups=[],this.layers=[],this.neurons=[],this.maxNumNeuronsPerGroup=0}numNeuronGroups(){return this.neuronGroups.length}numLayers(){return this.layers.length}numNeurons(){return this.neurons.length}numLinks(){return this.links.length}getInputNeuronGroup(){if(0==this.neuronGroups.length)throw new Error("no neuron groups available");return this.neuronGroups[0]}getOutputNeuronGroup(){if(0==this.neuronGroups.length)throw new Error("no neuron groups available");return this.neuronGroups[this.neuronGroups.length-1]}addNeuronGroup(t){null==t&&(t=0);const s=this.numNeuronGroups(),r=new d(this,s);this.neuronGroups.push(r);for(let s=0;s<t;s++)r.addNeuron();return r}addFullyConnectedLayer(t){if(0==this.neuronGroups.length)throw new Error("cannot add fully connected layer if no neuron groups exist");if(null==t)throw new Error("number of output neurons required to create fully connected layer");const s=this.getOutputNeuronGroup();this.addNeuronGroup(t);const r=this.getOutputNeuronGroup();s.neurons.forEach((t=>{r.neurons.forEach((s=>{this.addLink(t,s)}))}));const e=new c({inputNeuronGroup:s,outputNeuronGroup:r});return this.layers.push(e),e}addLink(t,s,r){const e=new l(this,t,s,r);return t.outputLinks.push(e),s.inputLinks.push(e),this.links.push(e),this.headless||this.svgLinks.appendChild(e.svgElement),e}zeroGrad(){this.neurons.forEach((t=>{t.zeroGrad()})),this.links.forEach((t=>{t.zeroGrad()}))}randomizeParameters(){this.links.forEach((t=>{let s=2+4*Math.random();Math.random()<=.5&&(s*=-1),t.weight=s})),this.neurons.forEach((t=>{let s=1+2*Math.random();Math.random()<=.5&&(s*=-1),t.bias=s}))}forward(t){if(null!=t){const s=this.getInputNeuronGroup(),r=s.neurons;if(t.length!=r.length)throw new Error(`invalid input size, expected ${s.length}, found ${t.length}`);r.forEach(((s,r)=>{s.activation=t[r]}))}for(let t=1;t<this.neuronGroups.length;t++){this.neuronGroups[t].forward()}if(null!=t){return this.getOutputNeuronGroup().getActivations()}}backward(t={}){for(let s=this.numLayers()-1;s>=0;s--){this.layers[s].backward(t)}}forwardData(t,s,r){const e=s-this.forward(t);return r.d=e,.5*e*e}backwardData(t){this.getOutputNeuronGroup().neurons[0].activationGrad=-t.d,this.backward()}forwardRegularization(t={}){const s=t.regularization??0;let r=0;return this.links.forEach((t=>{const e=t.weight;r+=.5*s*e*e})),r}backwardRegularization(t={}){this.links.forEach((s=>{s.backwardRegularization(t)}))}optimStep(t){if(null==t)throw new Error("lr required");this.links.forEach((s=>{s.optimStep(t)}));for(let s=1;s<this.neuronGroups.length;s++){this.neuronGroups[s].neurons.forEach((s=>{s.optimStep(t)}))}}train(t){const s=t.dataPoints;if(null==s)throw new Error("dataPoints required");const r=t.lr;if(null==r)throw new Error("lr required");const e=t.regularization??0,i=t.iters??1;let n,o;for(let t=0;t<i;t++)o=0,s.forEach((t=>{const s=[t.x,t.y],e=t.label,i={};o+=this.forwardData(s,e,i),this.zeroGrad(),this.backwardData(i),this.optimStep(r)})),n=this.forwardRegularization({regularization:e}),this.zeroGrad(),this.backwardRegularization({regularization:e}),this.optimStep(r);return{dataLoss:o,regularizationLoss:n}}render(){this.neuronGroups.forEach((t=>t.render())),this.links.forEach((t=>t.render()))}toData(){return{neuronGroups:this.neuronGroups.map((t=>t.toData())),links:this.links.map((t=>t.toData()))}}loadData(t){this.clear(),t.neuronGroups.forEach((t=>{d.fromData(this,t)}));for(let t=1;t<this.numNeuronGroups();t++){const s=this.neuronGroups[t-1],r=this.neuronGroups[t],e=new c({inputNeuronGroup:s,outputNeuronGroup:r});this.layers.push(e)}t.links.forEach((t=>{l.fromData(this,t)}))}static fromData(t,s={}){if(null==t)throw new Error("data required");const r=new g(s);return r.loadData(t),r}}var p={Sequential:g};const f=e;var m=class{constructor(t,s,r,e){this.canvas=t,this.x=s,this.y=r,this.label=e,this.radius=5}render(){const t=this.canvas.ctx,s=this.canvas.domElement.width,r=this.canvas.domElement.height;let e;e=0==this.label?f.red:f.blue;const i=e.blend(f.black,.6);t.beginPath(),t.fillStyle=e.toString(),t.strokeStyle=i.toString(),t.arc(this.x*s,this.y*r,this.radius,0,2*Math.PI),t.fill(),t.stroke()}toData(){return{x:this.x,y:this.y,label:this.label}}};const w=e,v=m,E=class{constructor(t){this.canvas=t,this._onDragBegin=this.onDragBegin.bind(this),t.addEventListener("mousedown",this._onDragBegin,{passive:!1}),t.addEventListener("touchstart",this._onDragBegin,{passive:!1}),this._onDragProgress=this.onDragProgress.bind(this),t.addEventListener("mousemove",this._onDragProgress,{passive:!1}),t.addEventListener("touchmove",this._onDragProgress,{passive:!1}),this._onDragEnd=this.onDragEnd.bind(this),window.addEventListener("mouseup",this._onDragEnd),window.addEventListener("touchend",this._onDragEnd),window.addEventListener("touchcancel",this._onDragEnd)}computeCursor(t){const s=this.canvas.getBoundingClientRect();let r,e;null==t.touches?(r=t.clientX,e=t.clientY):(r=t.touches[0].clientX,e=t.touches[0].clientY);const i={x:r-s.left,y:e-s.top};t.cursor=i}onDragBegin(t){t.preventDefault(),this.computeCursor(t),this.processDragBegin(t)}onDragProgress(t){null!=this.dragState&&(t.preventDefault(),this.computeCursor(t),this.processDragProgress(t))}onDragEnd(t){this.dragState=null}dragging(){return null!=this.dragState}};class G{constructor(t={}){if(!(this.headless=t.headless??!1)){const s=this.domElement=document.createElement("canvas");s.width=t.domWidth??250,s.height=t.domHeight??250;const r=s.getContext("2d",{willReadFrequently:!0});this.ctx=r,this.dragBehavior=new E(s),this.dragBehavior.processDragBegin=this.processDragBegin.bind(this),this.dragBehavior.processDragProgress=this.processDragProgress.bind(this)}this.dataWidth=t.dataWidth??50,this.dataHeight=t.dataHeight??50,this.dataPoints=[],this.clearPixels(),this.xyToPixel=(t,s)=>.5}clearPixels(){this.pixels=[];for(let t=0;t<this.dataWidth;t++){this.pixels.push([]);for(let s=0;s<this.dataHeight;s++)this.pixels[t].push(0)}}updatePixels(){const t=this.dataWidth,s=this.dataHeight;for(let r=0;r<t;r++)for(let e=0;e<s;e++){const i=this.xyToPixel(r/(t-1),e/(s-1));if(i<0||i>1)throw new Error(`pixel value must be between 0 and 1, found ${i}`);this.pixels[r][e]=i}}flushPixels(){const t=this.domElement,s=this.ctx,r=t.width,e=t.height,i=r/this.dataWidth,n=e/this.dataHeight;s.clearRect(0,0,r,e);const o=s.getImageData(0,0,r,e),a=o.data.length/4;for(let t=0;t<a;t++){const s=t%r,e=Math.floor(t/r),a=Math.floor(s/i),h=Math.floor(e/n),u=this.pixels[a][h],l=w.lightRed.blend(w.lightBlue,u),d=4*t;o.data[d]=Math.round(255*l.r),o.data[d+1]=Math.round(255*l.g),o.data[d+2]=Math.round(255*l.b),o.data[d+3]=255}s.putImageData(o,0,0)}addDataPoint(t,s,r){const e=new v(this,t,s,r);return this.dataPoints.push(e),e}clear(){this.dataPoints=[]}render(){this.updatePixels(),this.flushPixels(),this.dataPoints.forEach((t=>t.render()))}processDragBegin(t){for(let s=0;s<this.dataPoints.length;s++){const r=this.dataPoints[s],e=t.cursor.x-r.x*this.domElement.width,i=t.cursor.y-r.y*this.domElement.height,n=1.5*r.radius;if(e*e+i*i<=n*n){const t=this.dragBehavior.dragState={};t.dataPoint=r,t.offset={x:e,y:i};break}}}processDragProgress(t){const s=this.dragBehavior.dragState.dataPoint,r=this.dragBehavior.dragState.offset;s.x=(t.cursor.x-r.x)/this.domElement.width,s.y=(t.cursor.y-r.y)/this.domElement.height,s.x<0?s.x=0:s.x>1&&(s.x=1),s.y<0?s.y=0:s.y>1&&(s.y=1)}toData(){return this.dataPoints.map((t=>t.toData()))}loadFromData(t){this.dataPoints=[],t.forEach((t=>{this.addDataPoint(t.x,t.y,t.label)}))}static fromData(t){const s=new G;return s.loadFromData(t),s}}var b=G;var k={DataCanvas:b,LossPlot:class{constructor(t={}){const s=t.width??500,r=t.height??100,e=this.domElement=document.createElement("canvas");e.width=s,e.height=r,this.ctx=e.getContext("2d"),this.maxDataLength=s,this.data=[],this.minTopLoss=t.minTopLoss??4,this.topLoss=this.minTopLoss}push(t){this.data.length==this.maxDataLength&&this.data.shift(),this.data.push({totalLoss:t});const s=this.data.map((t=>t.totalLoss)),r=Math.max.apply(null,s);r>this.minTopLoss?this.topLoss=r:this.topLoss=this.minTopLoss,this.render()}render(){const t=this.ctx,s=this.domElement.width,r=this.domElement.height;t.clearRect(0,0,s,r),this.data.forEach(((e,i)=>{const n=e.totalLoss,o=i/(this.maxDataLength-1)*s,a=r*(1-n/this.topLoss);t.beginPath(),t.strokeStyle="rgb(255, 221, 78)",t.lineWidth=2,t.moveTo(o,r),t.lineTo(o,a),t.stroke()}))}clear(){this.data=[]}}};var D={common:{Color:e,svg:s},nn:p,ui:k,Sequential:p.Sequential,DataCanvas:k.DataCanvas};export{D as default};
=======
const t={createElement:function(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}};var s=t;class r{constructor(t,s,r,e){null==e&&(e=1),this.r=t,this.g=s,this.b=r,this.a=e}blend(t,s){if(Math.abs(s)>1)throw new Error("t must be a number between -1 and 1");let e,i;return s>=0?(e=this,i=t):(e=t,i=this),new r(e.r*(1-s)+i.r*s,e.g*(1-s)+i.g*s,e.b*(1-s)+i.b*s)}toString(){return`rgba(${Math.floor(255*this.r)}, ${Math.floor(255*this.g)}, ${Math.floor(255*this.b)}, ${this.a})`}}r.white=new r(1,1,1),r.black=new r(0,0,0),r.red=new r(226/255,86/255,86/255),r.blue=new r(135/255,173/255,236/255),r.lightBlue=new r(186/255,224/255,251/255),r.lightRed=new r(252/255,163/255,163/255);var e=r;var i=class{constructor(t,r,e,i){if(this.neuralNet=t,this.n0=r,this.nf=e,this.n0.group.id+1!=this.nf.group.id)throw new Error("Cannot connect neurons from non-consecutive groups");this.weight=null==i?1:i,this.weightGrad=0;const n=t.headless;if(this.headless=n,!n){const t=s;this.svgElement=t.createElement("path"),this.render()}}render(){const t=e,s=this.svgElement,r=this.n0.getPosition(),i=this.nf.getPosition();s.setAttribute("d","M"+r.x+" "+r.y+" L"+i.x+" "+i.y);const n=9*Math.min(1,Math.abs(this.weight)/5);let o;s.setAttribute("stroke-width",n),o=this.weight<0?t.red:t.blue,s.setAttribute("stroke-opacity",.4),s.setAttribute("stroke",o)}zeroGrad(){this.weightGrad=0}backward(t={}){const s=this.n0.activation,r=this.nf.preActivationGrad;this.n0.activationGrad+=r*this.weight,this.weightGrad+=r*s}forwardRegularization(t={}){return(t.regularization??0)*this.weight*this.weight*.5}backwardRegularization(t={}){const s=t.regularization??0;this.weightGrad+=s*this.weight}optimStep(t){if(null==t)throw new Error("lr required");this.weight-=t*this.weightGrad}toData(){const t={};return t.n0=[this.n0.group.id,this.n0.id],t.nf=[this.nf.group.id,this.nf.id],t.weight=this.weight,t}static fromData(t,s){const r=s.weight,e=s.n0,i=s.nf,n=t.neuronGroups[e[0]].neurons[e[1]],o=t.neuronGroups[i[0]].neurons[i[1]];return t.addLink(n,o,r)}};function n(t){return 1/(1+Math.exp(-t))}var o=class{constructor(t,r,e){this.group=t,this.id=r,this.outputLinks=[],this.inputLinks=[],this.bias=e,this.preActivation=0,this.activation=n(this.bias),this.activationGrad=0,this.preActivationGrad=0,this.biasGrad=0;const i=t.parent.headless;if(this.headless=i,!i){const t=s;(this.svgElement=t.createElement("circle")).setAttribute("r",12)}}forward(){this.preActivation=0,this.preActivation+=this.bias,this.inputLinks.forEach((t=>{this.preActivation+=t.weight*t.n0.activation})),this.activation=n(this.preActivation)}backward(t={}){this.preActivationGrad+=function(t,s){const r=n(t);return r*(1-r)*s}(this.preActivation,this.activationGrad),this.biasGrad+=this.preActivationGrad}optimStep(t){if(null==t)throw new Error("lr required");this.bias-=t*this.biasGrad}render(){const t=e,s=this.svgElement,r=this.getPosition();s.setAttribute("cx",r.x),s.setAttribute("cy",r.y);let i;if(0==this.inputLinks.length)i=t.blue.blend(t.red,.6);else{const s=3;const r=.5+Math.max(Math.min(this.bias,s),-s)/s*.5;i=t.red.blend(t.blue,r)}const n=i.blend(t.black,.3);s.setAttribute("fill",i.toString()),s.setAttribute("stroke",n.toString()),s.setAttribute("stroke-width",2)}getPosition(){const t=this.group.parent,s=this.group.numNeurons(),r=t.numNeuronGroups(),e=t.maxNumNeuronsPerGroup,i=t.width,n=t.height,o=n/2,a=(i-28)/(r-1),h=(n-28)/(e-1),u=i/2+(this.group.id-(r-1)/2)*a;let l;return l=0==s?o:o+(this.id-(s-1)/2)*h,{x:u,y:l}}zeroGrad(){this.activationGrad=0,this.preActivationGrad=0,this.biasGrad=0}toData(){return{bias:this.bias}}static fromData(t,s){t.addNeuron(s.bias)}};const a=o;var h=class{constructor(t,s){this.parent=t,this.id=s,this.neurons=[],this.headless=t.headless}numNeurons(){return this.neurons.length}addNeuron(t){const s=this.parent;null==t&&(t=.5);const r=this.numNeurons(),e=new a(this,r,t);return this.neurons.push(e),s.neurons.push(e),this.headless||s.svgNeurons.appendChild(e.svgElement),this.numNeurons()>s.maxNumNeuronsPerGroup&&(s.maxNumNeuronsPerGroup=this.numNeurons()),e}setActivations(t){const s=this.numNeurons();if(t.length!=s)throw new Error(`expected ${s} values, found ${t.length}`);for(let r=0;r<s;r++)this.neurons[r].activation=t[r]}getActivations(){return this.neurons.map((t=>t.activation))}forward(){this.neurons.forEach((t=>{t.forward()}))}render(){this.neurons.forEach((t=>{t.render()}))}toData(){return{neurons:this.neurons.map((t=>t.toData()))}}static fromData(t,s){const r=t.addNeuronGroup();s.neurons.forEach((t=>{a.fromData(r,t)}))}};class u{constructor(t){this.layer=t}*[Symbol.iterator](){const t=this.layer.outputNeuronGroup.neurons;for(let s=0;s<t.length;s++){const r=t[s];for(let t=0;t<r.inputLinks.length;t++)yield r.inputLinks[t]}}}const l=i,d=h,c=class{constructor(t={}){if(null==t.inputNeuronGroup)throw new Error("inputNeuronGroup required to create layer");if(null==t.outputNeuronGroup)throw new Error("outputNeuronGroup required to create layer");this.inputNeuronGroup=t.inputNeuronGroup,this.outputNeuronGroup=t.outputNeuronGroup,this.links=new u(this)}backward(t={}){this.outputNeuronGroup.neurons.forEach((s=>{s.backward(t)}));for(let s of this.links)s.backward(t)}getBiasArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{t.push(s.bias)})),t}getBiasGradArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{t.push(s.biasGrad)})),t}setBiasFromArray(t){const s=this.outputNeuronGroup.neurons;if(t.length!=s.length)throw new Error(`invalid bias size, found ${t.length}, expected ${s.length}`);s.forEach(((s,r)=>{s.bias=t[r]}))}getWeightArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{const r=[];t.push(r),s.inputLinks.forEach((t=>{r.push(t.weight)}))})),t}getWeightGradArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{const r=[];t.push(r),s.inputLinks.forEach((t=>{r.push(t.weightGrad)}))})),t}setWeightFromArray(t){this.inputNeuronGroup.neurons.forEach(((s,r)=>{s.outputLinks.forEach(((s,e)=>{s.weight=t[e][r]}))}))}};class g{constructor(t={}){this.neurons=[],this.links=[],this.neuronGroups=[],this.layers=[],this.maxNumNeuronsPerGroup=0;let r=t.headless??!0;const e=t.createDomElement??!1;if(e&&(r=!1),this.headless=r,!r){const r=s;if(this.svgElement=r.createElement("g"),this.svgLinks=r.createElement("g"),this.svgElement.appendChild(this.svgLinks),this.svgNeurons=r.createElement("g"),this.svgElement.appendChild(this.svgNeurons),e){const t=r.createElement("svg");t.appendChild(this.svgElement),this.domElement=t}const i=t.width??300,n=t.height??100;this.setRenderSize(i,n)}}setRenderSize(t,s){if(this.width=t,this.height=s,null!=this.domElement){const r=this.domElement;r.style.width=t,r.style.height=s}}clear(){if(!this.headless){for(;null!=this.svgLinks.firstChild;)this.svgLinks.removeChild(this.svgLinks.firstChild);for(;null!=this.svgNeurons.firstChild;)this.svgNeurons.removeChild(this.svgNeurons.firstChild)}this.links=[],this.neuronGroups=[],this.layers=[],this.neurons=[],this.maxNumNeuronsPerGroup=0}numNeuronGroups(){return this.neuronGroups.length}numLayers(){return this.layers.length}numNeurons(){return this.neurons.length}numLinks(){return this.links.length}getInputNeuronGroup(){if(0==this.neuronGroups.length)throw new Error("no neuron groups available");return this.neuronGroups[0]}getOutputNeuronGroup(){if(0==this.neuronGroups.length)throw new Error("no neuron groups available");return this.neuronGroups[this.neuronGroups.length-1]}addNeuronGroup(t){null==t&&(t=0);const s=this.numNeuronGroups(),r=new d(this,s);this.neuronGroups.push(r);for(let s=0;s<t;s++)r.addNeuron();return r}addFullyConnectedLayer(t){if(0==this.neuronGroups.length)throw new Error("cannot add fully connected layer if no neuron groups exist");if(null==t)throw new Error("number of output neurons required to create fully connected layer");const s=this.getOutputNeuronGroup();this.addNeuronGroup(t);const r=this.getOutputNeuronGroup();s.neurons.forEach((t=>{r.neurons.forEach((s=>{this.addLink(t,s)}))}));const e=new c({inputNeuronGroup:s,outputNeuronGroup:r});return this.layers.push(e),e}addLink(t,s,r){const e=new l(this,t,s,r);return t.outputLinks.push(e),s.inputLinks.push(e),this.links.push(e),this.headless||this.svgLinks.appendChild(e.svgElement),e}zeroGrad(){this.neurons.forEach((t=>{t.zeroGrad()})),this.links.forEach((t=>{t.zeroGrad()}))}randomizeParameters(){this.links.forEach((t=>{let s=2+4*Math.random();Math.random()<=.5&&(s*=-1),t.weight=s})),this.neurons.forEach((t=>{let s=1+2*Math.random();Math.random()<=.5&&(s*=-1),t.bias=s}))}forward(t){if(null!=t){const s=this.getInputNeuronGroup(),r=s.neurons;if(t.length!=r.length)throw new Error(`invalid input size, expected ${s.length}, found ${t.length}`);r.forEach(((s,r)=>{s.activation=t[r]}))}for(let t=1;t<this.neuronGroups.length;t++){this.neuronGroups[t].forward()}if(null!=t){return this.getOutputNeuronGroup().getActivations()}}backward(t={}){for(let s=this.numLayers()-1;s>=0;s--){this.layers[s].backward(t)}}forwardData(t,s,r){const e=s-this.forward(t);return r.d=e,.5*e*e}backwardData(t){this.getOutputNeuronGroup().neurons[0].activationGrad=-t.d,this.backward()}forwardRegularization(t={}){const s=t.regularization??0;let r=0;return this.links.forEach((t=>{const e=t.weight;r+=.5*s*e*e})),r}backwardRegularization(t={}){this.links.forEach((s=>{s.backwardRegularization(t)}))}optimStep(t){if(null==t)throw new Error("lr required");this.links.forEach((s=>{s.optimStep(t)}));for(let s=1;s<this.neuronGroups.length;s++){this.neuronGroups[s].neurons.forEach((s=>{s.optimStep(t)}))}}train(t){const s=t.dataPoints;if(null==s)throw new Error("dataPoints required");const r=t.lr;if(null==r)throw new Error("lr required");const e=t.regularization??0,i=t.iters??1;let n,o;for(let t=0;t<i;t++)o=0,s.forEach((t=>{const s=[t.x,t.y],e=t.label,i={};o+=this.forwardData(s,e,i),this.zeroGrad(),this.backwardData(i),this.optimStep(r)})),n=this.forwardRegularization({regularization:e}),this.zeroGrad(),this.backwardRegularization({regularization:e}),this.optimStep(r);return{dataLoss:o,regularizationLoss:n}}render(){this.neuronGroups.forEach((t=>t.render())),this.links.forEach((t=>t.render()))}toData(){return{neuronGroups:this.neuronGroups.map((t=>t.toData())),links:this.links.map((t=>t.toData()))}}loadData(t){this.clear(),t.neuronGroups.forEach((t=>{d.fromData(this,t)}));for(let t=1;t<this.numNeuronGroups();t++){const s=this.neuronGroups[t-1],r=this.neuronGroups[t],e=new c({inputNeuronGroup:s,outputNeuronGroup:r});this.layers.push(e)}t.links.forEach((t=>{l.fromData(this,t)}))}static fromData(t,s={}){if(null==t)throw new Error("data required");const r=new g(s);return r.loadData(t),r}}var p={Sequential:g};const f=e;var m=class{constructor(t,s,r,e){this.canvas=t,this.x=s,this.y=r,this.label=e,this.radius=5}render(){const t=this.canvas.ctx,s=this.canvas.domElement.width,r=this.canvas.domElement.height;let e;e=0==this.label?f.red:f.blue;const i=e.blend(f.black,.6);t.beginPath(),t.fillStyle=e.toString(),t.strokeStyle=i.toString(),t.arc(this.x*s,this.y*r,this.radius,0,2*Math.PI),t.fill(),t.stroke()}toData(){return{x:this.x,y:this.y,label:this.label}}};const w=e,v=m,E=class{constructor(t){this.canvas=t,this._onDragBegin=this.onDragBegin.bind(this),t.addEventListener("mousedown",this._onDragBegin,{passive:!1}),t.addEventListener("touchstart",this._onDragBegin,{passive:!1}),this._onDragProgress=this.onDragProgress.bind(this),t.addEventListener("mousemove",this._onDragProgress,{passive:!1}),t.addEventListener("touchmove",this._onDragProgress,{passive:!1}),this._onDragEnd=this.onDragEnd.bind(this),window.addEventListener("mouseup",this._onDragEnd),window.addEventListener("touchend",this._onDragEnd),window.addEventListener("touchcancel",this._onDragEnd)}computeCursor(t){const s=this.canvas.getBoundingClientRect();let r,e;null==t.touches?(r=t.clientX,e=t.clientY):(r=t.touches[0].clientX,e=t.touches[0].clientY);const i={x:r-s.left,y:e-s.top};t.cursor=i}onDragBegin(t){t.preventDefault(),this.computeCursor(t),this.processDragBegin(t)}onDragProgress(t){null!=this.dragState&&(t.preventDefault(),this.computeCursor(t),this.processDragProgress(t))}onDragEnd(t){this.dragState=null}dragging(){return null!=this.dragState}};class G{constructor(t={}){if(!(this.headless=t.headless??!1)){const s=this.domElement=document.createElement("canvas");s.width=t.domWidth??250,s.height=t.domHeight??250;const r=s.getContext("2d",{willReadFrequently:!0});this.ctx=r,this.dragBehavior=new E(s),this.dragBehavior.processDragBegin=this.processDragBegin.bind(this),this.dragBehavior.processDragProgress=this.processDragProgress.bind(this)}this.dataWidth=t.dataWidth??50,this.dataHeight=t.dataHeight??50,this.dataPoints=[],this.clearPixels(),this.xyToPixel=(t,s)=>.5}clearPixels(){this.pixels=[];for(let t=0;t<this.dataWidth;t++){this.pixels.push([]);for(let s=0;s<this.dataHeight;s++)this.pixels[t].push(0)}}updatePixels(){const t=this.dataWidth,s=this.dataHeight;for(let r=0;r<t;r++)for(let e=0;e<s;e++){const i=this.xyToPixel(r/(t-1),e/(s-1));if(i<0||i>1)throw new Error(`pixel value must be between 0 and 1, found ${i}`);this.pixels[r][e]=i}}flushPixels(){const t=this.domElement,s=this.ctx,r=t.width,e=t.height,i=r/this.dataWidth,n=e/this.dataHeight;s.clearRect(0,0,r,e);const o=s.getImageData(0,0,r,e),a=o.data.length/4;for(let t=0;t<a;t++){const s=t%r,e=Math.floor(t/r),a=Math.floor(s/i),h=Math.floor(e/n),u=this.pixels[a][h],l=w.lightRed.blend(w.lightBlue,u),d=4*t;o.data[d]=Math.round(255*l.r),o.data[d+1]=Math.round(255*l.g),o.data[d+2]=Math.round(255*l.b),o.data[d+3]=255}s.putImageData(o,0,0)}addDataPoint(t,s,r){const e=new v(this,t,s,r);return this.dataPoints.push(e),e}clear(){this.dataPoints=[]}render(){this.updatePixels(),this.flushPixels(),this.dataPoints.forEach((t=>t.render()))}processDragBegin(t){for(let s=0;s<this.dataPoints.length;s++){const r=this.dataPoints[s],e=t.cursor.x-r.x*this.domElement.width,i=t.cursor.y-r.y*this.domElement.height,n=1.5*r.radius;if(e*e+i*i<=n*n){const t=this.dragBehavior.dragState={};t.dataPoint=r,t.offset={x:e,y:i};break}}}processDragProgress(t){const s=this.dragBehavior.dragState.dataPoint,r=this.dragBehavior.dragState.offset;s.x=(t.cursor.x-r.x)/this.domElement.width,s.y=(t.cursor.y-r.y)/this.domElement.height,s.x<0?s.x=0:s.x>1&&(s.x=1),s.y<0?s.y=0:s.y>1&&(s.y=1)}toData(){return this.dataPoints.map((t=>t.toData()))}loadFromData(t){this.dataPoints=[],t.forEach((t=>{this.addDataPoint(t.x,t.y,t.label)}))}static fromData(t){const s=new G;return s.loadFromData(t),s}}var b=G;var k={ui:{DataCanvas:b,LossPlot:class{constructor(t={}){const s=t.width??500,r=t.height??100,e=this.domElement=document.createElement("canvas");e.width=s,e.height=r,this.ctx=e.getContext("2d"),this.maxDataLength=s,this.data=[],this.minTopLoss=t.minTopLoss??4,this.topLoss=this.minTopLoss}push(t){this.data.length==this.maxDataLength&&this.data.shift(),this.data.push({totalLoss:t});const s=this.data.map((t=>t.totalLoss)),r=Math.max.apply(null,s);r>this.minTopLoss?this.topLoss=r:this.topLoss=this.minTopLoss,this.render()}render(){const t=this.ctx,s=this.domElement.width,r=this.domElement.height;t.clearRect(0,0,s,r),this.data.forEach(((e,i)=>{const n=e.totalLoss,o=i/(this.maxDataLength-1)*s,a=r*(1-n/this.topLoss);t.beginPath(),t.strokeStyle="rgb(255, 221, 78)",t.lineWidth=2,t.moveTo(o,r),t.lineTo(o,a),t.stroke()}))}clear(){this.data=[]}}},common:{Color:e,svg:s},nn:p,Sequential:p.Sequential};export{k as default};
>>>>>>> master
