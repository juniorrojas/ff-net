const t={createElement:function(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}};var s=t;class e{constructor(t,s,e,r){null==r&&(r=1),this.r=t,this.g=s,this.b=e,this.a=r}blend(t,s){if(Math.abs(s)>1)throw new Error("t must be a number between -1 and 1");let r,i;return s>=0?(r=this,i=t):(r=t,i=this),new e(r.r*(1-s)+i.r*s,r.g*(1-s)+i.g*s,r.b*(1-s)+i.b*s)}toString(){return`rgba(${Math.floor(255*this.r)}, ${Math.floor(255*this.g)}, ${Math.floor(255*this.b)}, ${this.a})`}}e.white=new e(1,1,1),e.black=new e(0,0,0),e.red=new e(226/255,86/255,86/255),e.blue=new e(135/255,173/255,236/255),e.lightBlue=new e(186/255,224/255,251/255),e.lightRed=new e(252/255,163/255,163/255);var r=e;var i=class{constructor(t,e,r,i){if(this.sequential=t,this.n0=e,this.nf=r,this.n0.group.id+1!=this.nf.group.id)throw new Error("Cannot connect neurons from non-consecutive groups");this.weight=null==i?1:i,this.zeroGrad();const n=t.headless;if(this.headless=n,!n){const t=s;this.svgElement=t.createElement("path"),this.render()}}render(){const t=r,s=this.svgElement,e=this.n0.getPosition(),i=this.nf.getPosition();s.setAttribute("d","M"+e.x+" "+e.y+" L"+i.x+" "+i.y);const n=9*Math.min(1,Math.abs(this.weight)/5);let o;s.setAttribute("stroke-width",n),o=this.weight<0?t.red:t.blue,s.setAttribute("stroke-opacity",.4),s.setAttribute("stroke",o)}zeroGrad(){this.weightGrad=0}backward(t={}){const s=this.n0.activation,e=this.nf.preActivationGrad;this.n0.activationGrad+=e*this.weight,this.weightGrad+=e*s}forwardRegularization(t={}){return(t.regularization??0)*this.weight*this.weight*.5}backwardRegularization(t={}){const s=t.regularization??0;this.weightGrad+=s*this.weight}optimStep(t){if(null==t)throw new Error("lr required");this.weight-=t*this.weightGrad}toData(){const t={};return t.n0=[this.n0.group.id,this.n0.id],t.nf=[this.nf.group.id,this.nf.id],t.weight=this.weight,t}static fromData(t,s){const e=s.weight,r=s.n0,i=s.nf,n=t.neuronGroups[r[0]].neurons[r[1]],o=t.neuronGroups[i[0]].neurons[i[1]];return t.addLink(n,o,e)}};function n(t){return 1/(1+Math.exp(-t))}var o=class{constructor(t,e,r){this.group=t,this.id=e,this.outputLinks=[],this.inputLinks=[],this.bias=r,this.preActivation=0,this.activation=n(this.bias),this.zeroGrad();const i=t.sequential.headless;if(this.headless=i,!i){const t=s;(this.svgElement=t.createElement("circle")).setAttribute("r",12)}}forward(){this.preActivation=0,this.preActivation+=this.bias,this.inputLinks.forEach((t=>{this.preActivation+=t.weight*t.n0.activation})),this.activation=n(this.preActivation)}backward(t={}){this.preActivationGrad+=function(t,s){const e=n(t);return e*(1-e)*s}(this.preActivation,this.activationGrad),this.biasGrad+=this.preActivationGrad}optimStep(t){if(null==t)throw new Error("lr required");this.bias-=t*this.biasGrad}render(){const t=r,s=this.svgElement,e=this.getPosition();s.setAttribute("cx",e.x),s.setAttribute("cy",e.y);let i;if(0==this.inputLinks.length)i=t.blue.blend(t.red,.6);else{const s=3;const e=.5+Math.max(Math.min(this.bias,s),-s)/s*.5;i=t.red.blend(t.blue,e)}const n=i.blend(t.black,.3);s.setAttribute("fill",i.toString()),s.setAttribute("stroke",n.toString()),s.setAttribute("stroke-width",2)}getPosition(){const t=this.group.sequential,s=this.group.numNeurons(),e=t.numNeuronGroups(),r=t.maxNumNeuronsPerGroup,i=t.width,n=t.height,o=n/2,a=(i-28)/(e-1),h=(n-28)/(r-1),u=i/2+(this.group.id-(e-1)/2)*a;let l;return l=0==s?o:o+(this.id-(s-1)/2)*h,{x:u,y:l}}zeroGrad(){this.activationGrad=0,this.preActivationGrad=0,this.biasGrad=0}toData(){return{bias:this.bias}}static fromData(t,s){t.addNeuron(s.bias)}};const a=o;var h=class{constructor(t,s){this.sequential=t,this.id=s,this.neurons=[],this.headless=t.headless}numNeurons(){return this.neurons.length}addNeuron(t){const s=this.sequential;null==t&&(t=.5);const e=this.numNeurons(),r=new a(this,e,t);return this.neurons.push(r),s.neurons.push(r),this.headless||s.svgNeurons.appendChild(r.svgElement),this.numNeurons()>s.maxNumNeuronsPerGroup&&(s.maxNumNeuronsPerGroup=this.numNeurons()),r}setActivations(t){const s=this.numNeurons();if(t.length!=s)throw new Error(`expected ${s} values, found ${t.length}`);for(let e=0;e<s;e++)this.neurons[e].activation=t[e]}getActivations(){return this.neurons.map((t=>t.activation))}forward(){this.neurons.forEach((t=>{t.forward()}))}render(){this.neurons.forEach((t=>{t.render()}))}toData(){return{neurons:this.neurons.map((t=>t.toData()))}}static fromData(t,s){const e=t.addNeuronGroup();s.neurons.forEach((t=>{a.fromData(e,t)}))}};class u{constructor(t){this.layer=t}*[Symbol.iterator](){const t=this.layer.outputNeuronGroup.neurons;for(let s=0;s<t.length;s++){const e=t[s];for(let t=0;t<e.inputLinks.length;t++)yield e.inputLinks[t]}}}const l=i,d=h,c=class{constructor(t={}){if(null==t.inputNeuronGroup)throw new Error("inputNeuronGroup required to create layer");if(null==t.outputNeuronGroup)throw new Error("outputNeuronGroup required to create layer");this.inputNeuronGroup=t.inputNeuronGroup,this.outputNeuronGroup=t.outputNeuronGroup,this.links=new u(this)}backward(t={}){this.outputNeuronGroup.neurons.forEach((s=>{s.backward(t)}));for(let s of this.links)s.backward(t)}getBiasArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{t.push(s.bias)})),t}getBiasGradArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{t.push(s.biasGrad)})),t}setBiasFromArray(t){const s=this.outputNeuronGroup.neurons;if(t.length!=s.length)throw new Error(`invalid bias size, found ${t.length}, expected ${s.length}`);s.forEach(((s,e)=>{s.bias=t[e]}))}getWeightArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{const e=[];t.push(e),s.inputLinks.forEach((t=>{e.push(t.weight)}))})),t}getWeightGradArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((s=>{const e=[];t.push(e),s.inputLinks.forEach((t=>{e.push(t.weightGrad)}))})),t}setWeightFromArray(t){this.inputNeuronGroup.neurons.forEach(((s,e)=>{s.outputLinks.forEach(((s,r)=>{s.weight=t[r][e]}))}))}};class g{constructor(t={}){this.neurons=[],this.links=[],this.neuronGroups=[],this.layers=[],this.maxNumNeuronsPerGroup=0;let e=t.headless??!0;const r=t.createDomElement??!1;if(r&&(e=!1),this.headless=e,!e){const e=s;if(this.svgElement=e.createElement("g"),this.svgLinks=e.createElement("g"),this.svgElement.appendChild(this.svgLinks),this.svgNeurons=e.createElement("g"),this.svgElement.appendChild(this.svgNeurons),r){const t=e.createElement("svg");t.appendChild(this.svgElement),this.domElement=t}const i=t.width??300,n=t.height??100;this.setRenderSize(i,n)}}setRenderSize(t,s){if(this.width=t,this.height=s,null!=this.domElement){const e=this.domElement;e.style.width=t,e.style.height=s}}clear(){if(!this.headless){for(;null!=this.svgLinks.firstChild;)this.svgLinks.removeChild(this.svgLinks.firstChild);for(;null!=this.svgNeurons.firstChild;)this.svgNeurons.removeChild(this.svgNeurons.firstChild)}this.links=[],this.neuronGroups=[],this.layers=[],this.neurons=[],this.maxNumNeuronsPerGroup=0}numNeuronGroups(){return this.neuronGroups.length}numLayers(){return this.layers.length}numNeurons(){return this.neurons.length}numLinks(){return this.links.length}getInputNeuronGroup(){if(0==this.neuronGroups.length)throw new Error("no neuron groups available");return this.neuronGroups[0]}getOutputNeuronGroup(){if(0==this.neuronGroups.length)throw new Error("no neuron groups available");return this.neuronGroups[this.neuronGroups.length-1]}addNeuronGroup(t){null==t&&(t=0);const s=this.numNeuronGroups(),e=new d(this,s);this.neuronGroups.push(e);for(let s=0;s<t;s++)e.addNeuron();return e}addFullyConnectedLayer(t){if(0==this.neuronGroups.length)throw new Error("cannot add fully connected layer if no neuron groups exist");if(null==t)throw new Error("number of output neurons required to create fully connected layer");const s=this.getOutputNeuronGroup();this.addNeuronGroup(t);const e=this.getOutputNeuronGroup();s.neurons.forEach((t=>{e.neurons.forEach((s=>{this.addLink(t,s)}))}));const r=new c({inputNeuronGroup:s,outputNeuronGroup:e});return this.layers.push(r),r}addLink(t,s,e){const r=new l(this,t,s,e);return t.outputLinks.push(r),s.inputLinks.push(r),this.links.push(r),this.headless||this.svgLinks.appendChild(r.svgElement),r}zeroGrad(){this.neurons.forEach((t=>{t.zeroGrad()})),this.links.forEach((t=>{t.zeroGrad()}))}randomizeParameters(){this.links.forEach((t=>{let s=2+4*Math.random();Math.random()<=.5&&(s*=-1),t.weight=s})),this.neurons.forEach((t=>{let s=1+2*Math.random();Math.random()<=.5&&(s*=-1),t.bias=s}))}forward(t){if(null!=t){const s=this.getInputNeuronGroup(),e=s.neurons;if(t.length!=e.length)throw new Error(`invalid input size, expected ${s.length}, found ${t.length}`);e.forEach(((s,e)=>{s.activation=t[e]}))}for(let t=1;t<this.neuronGroups.length;t++){this.neuronGroups[t].forward()}if(null!=t){return this.getOutputNeuronGroup().getActivations()}}backward(t={}){for(let s=this.numLayers()-1;s>=0;s--){this.layers[s].backward(t)}}forwardData(t,s,e){const r=s-this.forward(t);return e.d=r,.5*r*r}backwardData(t){this.getOutputNeuronGroup().neurons[0].activationGrad=-t.d,this.backward()}forwardRegularization(t={}){const s=t.regularization??0;let e=0;return this.links.forEach((t=>{const r=t.weight;e+=.5*s*r*r})),e}backwardRegularization(t={}){this.links.forEach((s=>{s.backwardRegularization(t)}))}optimStep(t){if(null==t)throw new Error("lr required");this.links.forEach((s=>{s.optimStep(t)}));for(let s=1;s<this.neuronGroups.length;s++){this.neuronGroups[s].neurons.forEach((s=>{s.optimStep(t)}))}}train(t){const s=t.dataPoints;if(null==s)throw new Error("dataPoints required");const e=t.lr;if(null==e)throw new Error("lr required");const r=t.regularization??0,i=t.iters??1;let n,o;for(let t=0;t<i;t++)o=0,s.forEach((t=>{const s=[t.x,t.y],r=t.label,i={};o+=this.forwardData(s,r,i),this.zeroGrad(),this.backwardData(i),this.optimStep(e)})),n=this.forwardRegularization({regularization:r}),this.zeroGrad(),this.backwardRegularization({regularization:r}),this.optimStep(e);return{dataLoss:o,regularizationLoss:n}}render(){this.neuronGroups.forEach((t=>t.render())),this.links.forEach((t=>t.render()))}toData(){return{neuronGroups:this.neuronGroups.map((t=>t.toData())),links:this.links.map((t=>t.toData()))}}loadData(t){this.clear(),t.neuronGroups.forEach((t=>{d.fromData(this,t)}));for(let t=1;t<this.numNeuronGroups();t++){const s=this.neuronGroups[t-1],e=this.neuronGroups[t],r=new c({inputNeuronGroup:s,outputNeuronGroup:e});this.layers.push(r)}t.links.forEach((t=>{l.fromData(this,t)}))}static fromData(t,s={}){if(null==t)throw new Error("data required");const e=new g(s);return e.loadData(t),e}}var p={Sequential:g};const f=r;var m=class{constructor(t,s,e,r){this.canvas=t,this.x=s,this.y=e,this.label=r,this.radius=5}render(){const t=this.canvas.ctx,s=this.canvas.domElement.width,e=this.canvas.domElement.height;let r;r=0==this.label?f.red:f.blue;const i=r.blend(f.black,.6);t.beginPath(),t.fillStyle=r.toString(),t.strokeStyle=i.toString(),t.arc(this.x*s,this.y*e,this.radius,0,2*Math.PI),t.fill(),t.stroke()}toData(){return{x:this.x,y:this.y,label:this.label}}};const w=r,v=m,E=class{constructor(t){this.canvas=t,this._onDragBegin=this.onDragBegin.bind(this),t.addEventListener("mousedown",this._onDragBegin,{passive:!1}),t.addEventListener("touchstart",this._onDragBegin,{passive:!1}),this._onDragProgress=this.onDragProgress.bind(this),t.addEventListener("mousemove",this._onDragProgress,{passive:!1}),t.addEventListener("touchmove",this._onDragProgress,{passive:!1}),this._onDragEnd=this.onDragEnd.bind(this),window.addEventListener("mouseup",this._onDragEnd),window.addEventListener("touchend",this._onDragEnd),window.addEventListener("touchcancel",this._onDragEnd)}computeCursor(t){const s=this.canvas.getBoundingClientRect();let e,r;null==t.touches?(e=t.clientX,r=t.clientY):(e=t.touches[0].clientX,r=t.touches[0].clientY);const i={x:e-s.left,y:r-s.top};t.cursor=i}onDragBegin(t){t.preventDefault(),this.computeCursor(t),this.processDragBegin(t)}onDragProgress(t){null!=this.dragState&&(t.preventDefault(),this.computeCursor(t),this.processDragProgress(t))}onDragEnd(t){this.dragState=null}dragging(){return null!=this.dragState}};class G{constructor(t={}){if(!(this.headless=t.headless??!1)){const s=this.domElement=document.createElement("canvas");s.width=t.domWidth??250,s.height=t.domHeight??250;const e=s.getContext("2d",{willReadFrequently:!0});this.ctx=e,this.dragBehavior=new E(s),this.dragBehavior.processDragBegin=this.processDragBegin.bind(this),this.dragBehavior.processDragProgress=this.processDragProgress.bind(this)}this.dataWidth=t.dataWidth??50,this.dataHeight=t.dataHeight??50,this.dataPoints=[],this.clearPixels(),this.xyToPixel=(t,s)=>.5}clearPixels(){this.pixels=[];for(let t=0;t<this.dataWidth;t++){this.pixels.push([]);for(let s=0;s<this.dataHeight;s++)this.pixels[t].push(0)}}updatePixels(){const t=this.dataWidth,s=this.dataHeight;for(let e=0;e<t;e++)for(let r=0;r<s;r++){const i=this.xyToPixel(e/(t-1),r/(s-1));if(i<0||i>1)throw new Error(`pixel value must be between 0 and 1, found ${i}`);this.pixels[e][r]=i}}flushPixels(){const t=this.domElement,s=this.ctx,e=t.width,r=t.height,i=e/this.dataWidth,n=r/this.dataHeight;s.clearRect(0,0,e,r);const o=s.getImageData(0,0,e,r),a=o.data.length/4;for(let t=0;t<a;t++){const s=t%e,r=Math.floor(t/e),a=Math.floor(s/i),h=Math.floor(r/n),u=this.pixels[a][h],l=w.lightRed.blend(w.lightBlue,u),d=4*t;o.data[d]=Math.round(255*l.r),o.data[d+1]=Math.round(255*l.g),o.data[d+2]=Math.round(255*l.b),o.data[d+3]=255}s.putImageData(o,0,0)}addDataPoint(t,s,e){const r=new v(this,t,s,e);return this.dataPoints.push(r),r}clear(){this.dataPoints=[]}render(){this.updatePixels(),this.flushPixels(),this.dataPoints.forEach((t=>t.render()))}processDragBegin(t){for(let s=0;s<this.dataPoints.length;s++){const e=this.dataPoints[s],r=t.cursor.x-e.x*this.domElement.width,i=t.cursor.y-e.y*this.domElement.height,n=1.5*e.radius;if(r*r+i*i<=n*n){const t=this.dragBehavior.dragState={};t.dataPoint=e,t.offset={x:r,y:i};break}}}processDragProgress(t){const s=this.dragBehavior.dragState.dataPoint,e=this.dragBehavior.dragState.offset;s.x=(t.cursor.x-e.x)/this.domElement.width,s.y=(t.cursor.y-e.y)/this.domElement.height,s.x<0?s.x=0:s.x>1&&(s.x=1),s.y<0?s.y=0:s.y>1&&(s.y=1)}toData(){return this.dataPoints.map((t=>t.toData()))}loadFromData(t){this.dataPoints=[],t.forEach((t=>{this.addDataPoint(t.x,t.y,t.label)}))}static fromData(t){const s=new G;return s.loadFromData(t),s}}var b=G;var k={DataCanvas:b,LossPlot:class{constructor(t={}){const s=t.width??500,e=t.height??100,r=this.domElement=document.createElement("canvas");r.width=s,r.height=e,this.ctx=r.getContext("2d"),this.maxDataLength=s,this.data=[],this.minTopLoss=t.minTopLoss??4,this.topLoss=this.minTopLoss}push(t){this.data.length==this.maxDataLength&&this.data.shift(),this.data.push({totalLoss:t});const s=this.data.map((t=>t.totalLoss)),e=Math.max.apply(null,s);e>this.minTopLoss?this.topLoss=e:this.topLoss=this.minTopLoss,this.render()}render(){const t=this.ctx,s=this.domElement.width,e=this.domElement.height;t.clearRect(0,0,s,e),this.data.forEach(((r,i)=>{const n=r.totalLoss,o=i/(this.maxDataLength-1)*s,a=e*(1-n/this.topLoss);t.beginPath(),t.strokeStyle="rgb(255, 221, 78)",t.lineWidth=2,t.moveTo(o,e),t.lineTo(o,a),t.stroke()}))}clear(){this.data=[]}}};var D={common:{Color:r,svg:s},nn:p,ui:k,Sequential:p.Sequential,DataCanvas:k.DataCanvas};export{D as default};
