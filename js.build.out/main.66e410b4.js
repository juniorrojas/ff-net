const t={createElement:function(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}};var e=t;class n{constructor(t,e,n,s){null==s&&(s=1),this.r=t,this.g=e,this.b=n,this.a=s}blend(t,e){if(Math.abs(e)>1)throw new Error("t must be a number between -1 and 1");let s,r;return e>=0?(s=this,r=t):(s=t,r=this),new n(s.r*(1-e)+r.r*e,s.g*(1-e)+r.g*e,s.b*(1-e)+r.b*e)}toString(){return`rgba(${Math.floor(255*this.r)}, ${Math.floor(255*this.g)}, ${Math.floor(255*this.b)}, ${this.a})`}}n.white=new n(1,1,1),n.black=new n(0,0,0),n.red=new n(226/255,86/255,86/255),n.blue=new n(135/255,173/255,236/255),n.lightBlue=new n(186/255,224/255,251/255),n.lightRed=new n(252/255,163/255,163/255);var s=n;var r=class{constructor(t,n,s,r){if(this.sequential=t,this.n0=n,this.nf=s,this.n0.group.id+1!=this.nf.group.id)throw new Error("Cannot connect neurons from non-consecutive groups");this.weight=null==r?1:r,this.zeroGrad();const i=t.headless;if(this.headless=i,!i){const t=e;this.svgElement=t.createElement("path"),this.render()}}render(){const t=s,e=this.svgElement,n=this.n0.getPosition(),r=this.nf.getPosition();e.setAttribute("d","M"+n.x+" "+n.y+" L"+r.x+" "+r.y);const i=9*Math.min(1,Math.abs(this.weight)/5);let o;e.setAttribute("stroke-width",i),o=this.weight<0?t.red:t.blue,e.setAttribute("stroke-opacity",.4),e.setAttribute("stroke",o)}zeroGrad(){this.weightGrad=0}backward(t={}){const e=this.n0.activation,n=this.nf.preActivationGrad;this.n0.activationGrad+=n*this.weight,this.weightGrad+=n*e}forwardRegularization(t={}){return(t.regularization??0)*this.weight*this.weight*.5}backwardRegularization(t={}){const e=t.regularization??0;this.weightGrad+=e*this.weight}optimStep(t){if(null==t)throw new Error("lr required");this.weight-=t*this.weightGrad}toData(){const t={};return t.n0=[this.n0.group.id,this.n0.id],t.nf=[this.nf.group.id,this.nf.id],t.weight=this.weight,t}static fromData(t,e){const n=e.weight,s=e.n0,r=e.nf,i=t.neuronGroups[s[0]].neurons[s[1]],o=t.neuronGroups[r[0]].neurons[r[1]];return t.addLink(i,o,n)}};function i(t){return 1/(1+Math.exp(-t))}var o=class{constructor(t,n,s){this.group=t,this.id=n,this.outputLinks=[],this.inputLinks=[],this.bias=s,this.preActivation=0,this.activation=i(this.bias),this.zeroGrad();const r=t.sequential.headless;if(this.headless=r,!r){const t=e;(this.svgElement=t.createElement("circle")).setAttribute("r",12)}}forward(){this.preActivation=0,this.preActivation+=this.bias,this.inputLinks.forEach((t=>{this.preActivation+=t.weight*t.n0.activation})),this.activation=i(this.preActivation)}backward(t={}){this.preActivationGrad+=function(t,e){const n=i(t);return n*(1-n)*e}(this.preActivation,this.activationGrad),this.biasGrad+=this.preActivationGrad}optimStep(t){if(null==t)throw new Error("lr required");this.bias-=t*this.biasGrad}render(){const t=s,e=this.svgElement,n=this.getPosition();e.setAttribute("cx",n.x),e.setAttribute("cy",n.y);let r;if(0==this.inputLinks.length)r=t.blue.blend(t.red,.6);else{const e=3;const n=.5+Math.max(Math.min(this.bias,e),-e)/e*.5;r=t.red.blend(t.blue,n)}const i=r.blend(t.black,.3);e.setAttribute("fill",r.toString()),e.setAttribute("stroke",i.toString()),e.setAttribute("stroke-width",2)}getPosition(){const t=this.group.sequential,e=this.group.numNeurons(),n=t.numNeuronGroups(),s=t.maxNumNeuronsPerGroup,r=t.width,i=t.height,o=i/2,a=(r-28)/(n-1),h=(i-28)/(s-1),l=r/2+(this.group.id-(n-1)/2)*a;let u;return u=0==e?o:o+(this.id-(e-1)/2)*h,{x:l,y:u}}zeroGrad(){this.activationGrad=0,this.preActivationGrad=0,this.biasGrad=0}toData(){return{bias:this.bias}}static fromData(t,e){t.addNeuron(e.bias)}};const a=o;var h=class{constructor(t,e){this.sequential=t,this.id=e,this.neurons=[],this.headless=t.headless}numNeurons(){return this.neurons.length}addNeuron(t){const e=this.sequential;null==t&&(t=.5);const n=this.numNeurons(),s=new a(this,n,t);return this.neurons.push(s),e.neurons.push(s),this.headless||e.svgNeurons.appendChild(s.svgElement),this.numNeurons()>e.maxNumNeuronsPerGroup&&(e.maxNumNeuronsPerGroup=this.numNeurons()),s}setActivations(t){const e=this.numNeurons();if(t.length!=e)throw new Error(`expected ${e} values, found ${t.length}`);for(let n=0;n<e;n++)this.neurons[n].activation=t[n]}getActivations(){return this.neurons.map((t=>t.activation))}forward(){this.neurons.forEach((t=>{t.forward()}))}render(){this.neurons.forEach((t=>{t.render()}))}toData(){return{neurons:this.neurons.map((t=>t.toData()))}}static fromData(t,e){const n=t.addNeuronGroup();e.neurons.forEach((t=>{a.fromData(n,t)}))}};class l{constructor(t){this.layer=t}*[Symbol.iterator](){const t=this.layer.outputNeuronGroup.neurons;for(let e=0;e<t.length;e++){const n=t[e];for(let t=0;t<n.inputLinks.length;t++)yield n.inputLinks[t]}}}const u=r,d=h,c=class{constructor(t={}){if(null==t.inputNeuronGroup)throw new Error("inputNeuronGroup required to create layer");if(null==t.outputNeuronGroup)throw new Error("outputNeuronGroup required to create layer");this.inputNeuronGroup=t.inputNeuronGroup,this.outputNeuronGroup=t.outputNeuronGroup,this.links=new l(this)}backward(t={}){this.outputNeuronGroup.neurons.forEach((e=>{e.backward(t)}));for(let e of this.links)e.backward(t)}getBiasArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((e=>{t.push(e.bias)})),t}getBiasGradArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((e=>{t.push(e.biasGrad)})),t}setBiasFromArray(t){const e=this.outputNeuronGroup.neurons;if(t.length!=e.length)throw new Error(`invalid bias size, found ${t.length}, expected ${e.length}`);e.forEach(((e,n)=>{e.bias=t[n]}))}getWeightArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((e=>{const n=[];t.push(n),e.inputLinks.forEach((t=>{n.push(t.weight)}))})),t}getWeightGradArray(){const t=[];return this.outputNeuronGroup.neurons.forEach((e=>{const n=[];t.push(n),e.inputLinks.forEach((t=>{n.push(t.weightGrad)}))})),t}setWeightFromArray(t){this.inputNeuronGroup.neurons.forEach(((e,n)=>{e.outputLinks.forEach(((e,s)=>{e.weight=t[s][n]}))}))}};class p{constructor(t={}){this.neurons=[],this.links=[],this.neuronGroups=[],this.layers=[],this.maxNumNeuronsPerGroup=0;let n=t.headless??!0;const s=t.createDomElement??!1;if(s&&(n=!1),this.headless=n,!n){const n=e;if(this.svgElement=n.createElement("g"),this.svgLinks=n.createElement("g"),this.svgElement.appendChild(this.svgLinks),this.svgNeurons=n.createElement("g"),this.svgElement.appendChild(this.svgNeurons),s){const t=n.createElement("svg");t.appendChild(this.svgElement),this.domElement=t}const r=t.width??300,i=t.height??100;this.setRenderSize(r,i)}}setRenderSize(t,e){if(this.width=t,this.height=e,null!=this.domElement){const n=this.domElement;n.style.width=t,n.style.height=e}}clear(){if(!this.headless){for(;null!=this.svgLinks.firstChild;)this.svgLinks.removeChild(this.svgLinks.firstChild);for(;null!=this.svgNeurons.firstChild;)this.svgNeurons.removeChild(this.svgNeurons.firstChild)}this.links=[],this.neuronGroups=[],this.layers=[],this.neurons=[],this.maxNumNeuronsPerGroup=0}numNeuronGroups(){return this.neuronGroups.length}numLayers(){return this.layers.length}numNeurons(){return this.neurons.length}numLinks(){return this.links.length}getInputNeuronGroup(){if(0==this.neuronGroups.length)throw new Error("no neuron groups available");return this.neuronGroups[0]}getOutputNeuronGroup(){if(0==this.neuronGroups.length)throw new Error("no neuron groups available");return this.neuronGroups[this.neuronGroups.length-1]}addNeuronGroup(t){null==t&&(t=0);const e=this.numNeuronGroups(),n=new d(this,e);this.neuronGroups.push(n);for(let e=0;e<t;e++)n.addNeuron();return n}addFullyConnectedLayer(t){if(0==this.neuronGroups.length)throw new Error("cannot add fully connected layer if no neuron groups exist");if(null==t)throw new Error("number of output neurons required to create fully connected layer");const e=this.getOutputNeuronGroup();this.addNeuronGroup(t);const n=this.getOutputNeuronGroup();e.neurons.forEach((t=>{n.neurons.forEach((e=>{this.addLink(t,e)}))}));const s=new c({inputNeuronGroup:e,outputNeuronGroup:n});return this.layers.push(s),s}addLink(t,e,n){const s=new u(this,t,e,n);return t.outputLinks.push(s),e.inputLinks.push(s),this.links.push(s),this.headless||this.svgLinks.appendChild(s.svgElement),s}zeroGrad(){this.neurons.forEach((t=>{t.zeroGrad()})),this.links.forEach((t=>{t.zeroGrad()}))}randomizeParameters(){this.links.forEach((t=>{let e=2+4*Math.random();Math.random()<=.5&&(e*=-1),t.weight=e})),this.neurons.forEach((t=>{let e=1+2*Math.random();Math.random()<=.5&&(e*=-1),t.bias=e}))}forward(t){if(null!=t){const e=this.getInputNeuronGroup(),n=e.neurons;if(t.length!=n.length)throw new Error(`invalid input size, expected ${e.length}, found ${t.length}`);n.forEach(((e,n)=>{e.activation=t[n]}))}for(let t=1;t<this.neuronGroups.length;t++){this.neuronGroups[t].forward()}if(null!=t){return this.getOutputNeuronGroup().getActivations()}}backward(t={}){for(let e=this.numLayers()-1;e>=0;e--){this.layers[e].backward(t)}}forwardData(t,e,n){const s=e-this.forward(t);return n.d=s,.5*s*s}backwardData(t){this.getOutputNeuronGroup().neurons[0].activationGrad=-t.d,this.backward()}forwardRegularization(t={}){const e=t.regularization??0;let n=0;return this.links.forEach((t=>{const s=t.weight;n+=.5*e*s*s})),n}backwardRegularization(t={}){this.links.forEach((e=>{e.backwardRegularization(t)}))}optimStep(t){if(null==t)throw new Error("lr required");this.links.forEach((e=>{e.optimStep(t)}));for(let e=1;e<this.neuronGroups.length;e++){this.neuronGroups[e].neurons.forEach((e=>{e.optimStep(t)}))}}train(t){const e=t.dataPoints;if(null==e)throw new Error("dataPoints required");const n=t.lr;if(null==n)throw new Error("lr required");const s=t.regularization??0,r=t.iters??1;let i,o;for(let t=0;t<r;t++)o=0,e.forEach((t=>{const e=[t.x,t.y],s=t.label,r={};o+=this.forwardData(e,s,r),this.zeroGrad(),this.backwardData(r),this.optimStep(n)})),i=this.forwardRegularization({regularization:s}),this.zeroGrad(),this.backwardRegularization({regularization:s}),this.optimStep(n);return{dataLoss:o,regularizationLoss:i}}render(){this.neuronGroups.forEach((t=>t.render())),this.links.forEach((t=>t.render()))}toData(){return{neuronGroups:this.neuronGroups.map((t=>t.toData())),links:this.links.map((t=>t.toData()))}}loadData(t){this.clear(),t.neuronGroups.forEach((t=>{d.fromData(this,t)}));for(let t=1;t<this.numNeuronGroups();t++){const e=this.neuronGroups[t-1],n=this.neuronGroups[t],s=new c({inputNeuronGroup:e,outputNeuronGroup:n});this.layers.push(s)}t.links.forEach((t=>{u.fromData(this,t)}))}static fromData(t,e={}){if(null==t)throw new Error("data required");const n=new p(e);return n.loadData(t),n}}var g={Sequential:p};const m=s;var w=class{constructor(t,e,n,s){this.canvas=t,this.x=e,this.y=n,this.label=s,this.radius=5}render(){const t=this.canvas.ctx,e=this.canvas.domElement.width,n=this.canvas.domElement.height;let s;s=0==this.label?m.red:m.blue;const r=s.blend(m.black,.6);t.beginPath(),t.fillStyle=s.toString(),t.strokeStyle=r.toString(),t.arc(this.x*e,this.y*n,this.radius,0,2*Math.PI),t.fill(),t.stroke()}toData(){return{x:this.x,y:this.y,label:this.label}}};const f=s,b=w,x=class{constructor(t){this.canvas=t,this._onDragBegin=this.onDragBegin.bind(this),t.addEventListener("mousedown",this._onDragBegin,{passive:!1}),t.addEventListener("touchstart",this._onDragBegin,{passive:!1}),this._onDragProgress=this.onDragProgress.bind(this),t.addEventListener("mousemove",this._onDragProgress,{passive:!1}),t.addEventListener("touchmove",this._onDragProgress,{passive:!1}),this._onDragEnd=this.onDragEnd.bind(this),window.addEventListener("mouseup",this._onDragEnd),window.addEventListener("touchend",this._onDragEnd),window.addEventListener("touchcancel",this._onDragEnd)}computeCursor(t){const e=this.canvas.getBoundingClientRect();let n,s;null==t.touches?(n=t.clientX,s=t.clientY):(n=t.touches[0].clientX,s=t.touches[0].clientY);const r={x:n-e.left,y:s-e.top};t.cursor=r}onDragBegin(t){t.preventDefault(),this.computeCursor(t),this.processDragBegin(t)}onDragProgress(t){null!=this.dragState&&(t.preventDefault(),this.computeCursor(t),this.processDragProgress(t))}onDragEnd(t){this.dragState=null}dragging(){return null!=this.dragState}};class E{constructor(t={}){if(!(this.headless=t.headless??!1)){const e=this.domElement=document.createElement("canvas");e.width=t.domWidth??250,e.height=t.domHeight??250;const n=e.getContext("2d",{willReadFrequently:!0});this.ctx=n,this.dragBehavior=new x(e),this.dragBehavior.processDragBegin=this.processDragBegin.bind(this),this.dragBehavior.processDragProgress=this.processDragProgress.bind(this)}this.dataWidth=t.dataWidth??50,this.dataHeight=t.dataHeight??50,this.dataPoints=[],this.clearPixels(),this.xyToPixel=(t,e)=>.5}clearPixels(){this.pixels=[];for(let t=0;t<this.dataWidth;t++){this.pixels.push([]);for(let e=0;e<this.dataHeight;e++)this.pixels[t].push(0)}}updatePixels(){const t=this.dataWidth,e=this.dataHeight;for(let n=0;n<t;n++)for(let s=0;s<e;s++){const r=this.xyToPixel(n/(t-1),s/(e-1));if(r<0||r>1)throw new Error(`pixel value must be between 0 and 1, found ${r}`);this.pixels[n][s]=r}}flushPixels(){const t=this.domElement,e=this.ctx,n=t.width,s=t.height,r=n/this.dataWidth,i=s/this.dataHeight;e.clearRect(0,0,n,s);const o=e.getImageData(0,0,n,s),a=o.data.length/4;for(let t=0;t<a;t++){const e=t%n,s=Math.floor(t/n),a=Math.floor(e/r),h=Math.floor(s/i),l=this.pixels[a][h],u=f.lightRed.blend(f.lightBlue,l),d=4*t;o.data[d]=Math.round(255*u.r),o.data[d+1]=Math.round(255*u.g),o.data[d+2]=Math.round(255*u.b),o.data[d+3]=255}e.putImageData(o,0,0)}addDataPoint(t,e,n){const s=new b(this,t,e,n);return this.dataPoints.push(s),s}clear(){this.dataPoints=[]}render(){this.updatePixels(),this.flushPixels(),this.dataPoints.forEach((t=>t.render()))}processDragBegin(t){for(let e=0;e<this.dataPoints.length;e++){const n=this.dataPoints[e],s=t.cursor.x-n.x*this.domElement.width,r=t.cursor.y-n.y*this.domElement.height,i=1.5*n.radius;if(s*s+r*r<=i*i){const t=this.dragBehavior.dragState={};t.dataPoint=n,t.offset={x:s,y:r};break}}}processDragProgress(t){const e=this.dragBehavior.dragState.dataPoint,n=this.dragBehavior.dragState.offset;e.x=(t.cursor.x-n.x)/this.domElement.width,e.y=(t.cursor.y-n.y)/this.domElement.height,e.x<0?e.x=0:e.x>1&&(e.x=1),e.y<0?e.y=0:e.y>1&&(e.y=1)}toData(){return this.dataPoints.map((t=>t.toData()))}loadFromData(t){this.dataPoints=[],t.forEach((t=>{this.addDataPoint(t.x,t.y,t.label)}))}static fromData(t){const e=new E;return e.loadFromData(t),e}}var v=E;var y={DataCanvas:v,LossPlot:class{constructor(t={}){const e=t.width??500,n=t.height??100,s=this.domElement=document.createElement("canvas");s.width=e,s.height=n,this.ctx=s.getContext("2d"),this.maxDataLength=e,this.data=[],this.minTopLoss=t.minTopLoss??4,this.topLoss=this.minTopLoss}push(t){this.data.length==this.maxDataLength&&this.data.shift(),this.data.push({totalLoss:t});const e=this.data.map((t=>t.totalLoss)),n=Math.max.apply(null,e);n>this.minTopLoss?this.topLoss=n:this.topLoss=this.minTopLoss,this.render()}render(){const t=this.ctx,e=this.domElement.width,n=this.domElement.height;t.clearRect(0,0,e,n),this.data.forEach(((s,r)=>{const i=s.totalLoss,o=r/(this.maxDataLength-1)*e,a=n*(1-i/this.topLoss);t.beginPath(),t.strokeStyle="rgb(255, 221, 78)",t.lineWidth=2,t.moveTo(o,n),t.lineTo(o,a),t.stroke()}))}clear(){this.data=[]}}};var G={common:{Color:s,svg:e},nn:g,ui:y,Sequential:g.Sequential,DataCanvas:y.DataCanvas};class L extends G.ui.LossPlot{constructor(t={}){super(t),this.domElement.className="loss-plot";const e=window.matchMedia("(max-width: 530px)"),n=()=>{e.matches?(this.domElement.style.width="250px",this.domElement.style.height="50px"):(this.domElement.style.width="500px",this.domElement.style.height="100px")};e.addEventListener("change",(t=>{n()})),n()}}class C{constructor(t={}){const e=document.createElement("input");this.domElement=e,e.type="range",e.min=t.min??0,e.max=t.max??100,e.step=t.step??1,null!=t.value&&(e.value=t.value),null!=t.onUpdate&&e.addEventListener("input",(()=>{const n=parseFloat(e.value);t.onUpdate(n)}))}}class N{constructor(){(this.domElement=document.createElement("div")).className="control-row",this.cells=[],this.control=null}addCell(){const t=document.createElement("div");return t.className="control-cell",this.domElement.appendChild(t),this.cells.push(t),t}}class k{constructor(t={}){this.learningRate=.08,this.regularization=.001;let e;(this.domElement=document.createElement("div")).classList.add("control-panel"),this.rows=[],e=this.addFullRow();const n=document.createElement("div");n.textContent="randomize network parameters",n.className="btn",e.cells[0].appendChild(n);const s=t.model;n.addEventListener("click",(()=>{s.randomizeParameters()})),this.addControlRow("slider","learning rate",{min:.005,max:.5,step:.01,value:this.learningRate,onUpdate:t=>{this.learningRate=t}}),this.addControlRow("slider","regularization",{min:0,max:.0051,step:1e-5,value:this.regularization,onUpdate:t=>{this.regularization=t}}),e=this.addControlRow("text","loss"),e.control.className="formatted-number",this.rowLoss=e,e=this.addFullRow();const r=this.lossPlot=new L;e.cells[0].appendChild(r.domElement)}addRow(){const t=new N;return this.domElement.appendChild(t.domElement),this.rows.push(t),t}addFullRow(){const t=this.addRow(),e=document.createElement("div");return e.className="control-cell-full",t.domElement.appendChild(e),t.cells.push(e),t}addControlRow(t,e,n={}){const s=this.addRow();let r,i;switch(r=s.addCell(),r.textContent=e,r=s.addCell(),t){case"slider":i=new C(n);break;case"text":i=r;break;default:throw new Error(`invalid control type ${t}`)}return i!=r&&r.appendChild(i.domElement),s.control=i,s}update(t){if(null==t.dataLoss)throw new Error("dataLoss required to update panel");if(null==t.regularizationLoss)throw new Error("regularizationLoss required to update panel");const e=t.dataLoss+t.regularizationLoss;this.rowLoss.control.textContent=e.toFixed(10),this.lossPlot.push(e)}}class D{constructor(t){const e=document.createElement("div");let n;e.className="content-container",this.domElement=e,n=document.createElement("div"),e.appendChild(n),n.className="content-container-row";const s=this.model=G.Sequential.fromData(t.model,{headless:!1,createDomElement:!0});s.domElement.classList.add("content-container-cell"),s.setRenderSize(300,250),n.appendChild(s.domElement),s.render();const r=this.dataCanvas=G.ui.DataCanvas.fromData(t.dataPoints);r.domElement.classList.add("content-container-cell"),r.domElement.id="data-canvas",n.appendChild(r.domElement),n=document.createElement("div"),e.appendChild(n),n.className="content-container-row";const i=this.controlPanel=new k({model:s});i.domElement.classList.add("content-container-cell"),n.appendChild(i.domElement),this.paused=!1,r.xyToPixel=(t,e)=>(s.getInputNeuronGroup().setActivations([t,e]),s.forward(),s.getOutputNeuronGroup().neurons[0].activation),this.renderLoop(),setInterval((()=>{this.update()}),1e3/60)}update(){if(!this.paused){const t=this.model,e=this.dataCanvas,{dataLoss:n,regularizationLoss:s}=t.train({lr:this.controlPanel.learningRate,regularization:this.controlPanel.regularization,iters:10,dataPoints:e.dataPoints});this.controlPanel.update({dataLoss:n,regularizationLoss:s})}}renderLoop(){this.model.render(),this.dataCanvas.render(),requestAnimationFrame((()=>{this.renderLoop()}))}toData(){return{dataPoints:this.dataCanvas.toData(),model:this.model.toData()}}pause(){this.paused=!0}unpause(){this.paused=!1}}var P={dataPoints:[{x:.08,y:.24,label:1},{x:.2,y:.27,label:1},{x:.05,y:.3,label:1},{x:.1,y:.1,label:1},{x:.4,y:.4,label:0},{x:.6,y:.4,label:0},{x:.65,y:.7,label:0},{x:.7,y:.3,label:0},{x:.35,y:.65,label:0},{x:.3,y:.5,label:0},{x:.7,y:.5,label:0},{x:.75,y:.55,label:0},{x:.7,y:.6,label:0},{x:.65,y:.34,label:0},{x:.8,y:.65,label:0},{x:.5,y:.7,label:0},{x:.5,y:.66,label:0},{x:.56,y:.66,label:0},{x:.46,y:.36,label:0},{x:.46,y:.26,label:0},{x:.36,y:.26,label:0},{x:.26,y:.36,label:0},{x:.56,y:.28,label:0},{x:.33,y:.54,label:0},{x:.23,y:.52,label:0},{x:.26,y:.16,label:1},{x:.06,y:.46,label:1},{x:.13,y:.66,label:1},{x:.2,y:.8,label:1},{x:.5,y:.5,label:1},{x:.45,y:.5,label:1},{x:.5,y:.45,label:1},{x:.45,y:.45,label:1},{x:.55,y:.55,label:1},{x:.5,y:.55,label:1},{x:.5,y:.2,label:1},{x:.4,y:.1,label:1},{x:.6,y:.1,label:1},{x:.75,y:.15,label:1},{x:.88,y:.22,label:1},{x:.9,y:.35,label:1},{x:.9,y:.49,label:1},{x:.88,y:.62,label:1},{x:.9,y:.9,label:1},{x:.9,y:.8,label:1},{x:.75,y:.85,label:1},{x:.55,y:.92,label:1},{x:.6,y:.95,label:1},{x:.06,y:.57,label:1},{x:.09,y:.8,label:1},{x:.4,y:.9,label:1}],model:{neuronGroups:[{neurons:[{bias:.5},{bias:.5}]},{neurons:[{bias:.2731707327259464},{bias:.3131750543526207},{bias:.3113708416049979},{bias:.4878756278417343},{bias:.368218822643312}]},{neurons:[{bias:.5512422501720741},{bias:.5672616111773106},{bias:-.052479036776262165},{bias:.5222729688284673},{bias:.01215000568099761}]},{neurons:[{bias:.5001970006319566},{bias:.0180989829714042}]},{neurons:[{bias:1.9819147663745404}]}],links:[{n0:[0,0],nf:[1,0],weight:2.2477214362553712},{n0:[0,0],nf:[1,1],weight:4.026412497443965},{n0:[0,0],nf:[1,2],weight:-5.917043453417338},{n0:[0,0],nf:[1,3],weight:-2.68761418492447},{n0:[0,0],nf:[1,4],weight:-4.444127402013615},{n0:[0,1],nf:[1,0],weight:2.6053358948986336},{n0:[0,1],nf:[1,1],weight:-2.732960971580873},{n0:[0,1],nf:[1,2],weight:2.7636999530265784},{n0:[0,1],nf:[1,3],weight:-2.095874033983207},{n0:[0,1],nf:[1,4],weight:2.5249833832053143},{n0:[1,0],nf:[2,0],weight:-2.823233139082371},{n0:[1,0],nf:[2,1],weight:2.3963314743951263},{n0:[1,0],nf:[2,2],weight:2.2151128533448103},{n0:[1,0],nf:[2,3],weight:2.14835431884995},{n0:[1,0],nf:[2,4],weight:2.5921383874196815},{n0:[1,1],nf:[2,0],weight:-2.438292678759993},{n0:[1,1],nf:[2,1],weight:2.8063251377616543},{n0:[1,1],nf:[2,2],weight:-5.065396210015049},{n0:[1,1],nf:[2,3],weight:-3.243042335136095},{n0:[1,1],nf:[2,4],weight:2.542395895887639},{n0:[1,2],nf:[2,0],weight:5.404030554604219},{n0:[1,2],nf:[2,1],weight:1.7863015498992876},{n0:[1,2],nf:[2,2],weight:1.0784128587386383},{n0:[1,2],nf:[2,3],weight:3.923879311898695},{n0:[1,2],nf:[2,4],weight:-5.862725941349154},{n0:[1,3],nf:[2,0],weight:4.361572850233568},{n0:[1,3],nf:[2,1],weight:-3.794297602180668},{n0:[1,3],nf:[2,2],weight:-4.306628432557914},{n0:[1,3],nf:[2,3],weight:1.8299769906529855},{n0:[1,3],nf:[2,4],weight:3.84025797153971},{n0:[1,4],nf:[2,0],weight:-3.2400189683428624},{n0:[1,4],nf:[2,1],weight:4.547306298242339},{n0:[1,4],nf:[2,2],weight:-4.903641978578267},{n0:[1,4],nf:[2,3],weight:-3.434543827170914},{n0:[1,4],nf:[2,4],weight:2.5852132299496007},{n0:[2,0],nf:[3,0],weight:-4.24959667054963},{n0:[2,0],nf:[3,1],weight:-3.493229143121218},{n0:[2,1],nf:[3,0],weight:4.084128926311857},{n0:[2,1],nf:[3,1],weight:-4.232014075010303},{n0:[2,2],nf:[3,0],weight:4.552325217373535},{n0:[2,2],nf:[3,1],weight:2.5580329005701867},{n0:[2,3],nf:[3,0],weight:2.314900339470761},{n0:[2,3],nf:[3,1],weight:1.7506827877945348},{n0:[2,4],nf:[3,0],weight:4.423538736207089},{n0:[2,4],nf:[3,1],weight:3.5987701319112593},{n0:[3,0],nf:[4,0],weight:.7493929815769563},{n0:[3,1],nf:[4,0],weight:-3.9177235746869705}]}};const z="rgb(46, 53, 56)";function A(){!function(){const t=document.createElement("a");document.body.appendChild(t),t.href="https://github.com/juniorrojas/ff-net",t.classList.add("github-corner"),t.ariaLabel="View source on GitHub";const e=z;t.innerHTML=`<svg class="view-on-github" width="80" height="80" viewBox="0 0 250 250" style="fill:yellow; color:${e}; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.view-on-github{cursor: pointer}.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>`}(),function(){const t=document.createElement("div");var e;document.body.appendChild(t),t.className="title-container",(e=t.style).backgroundColor=z,e.paddingTop="25px",e.paddingBottom="5px",e.paddingRight="5px",e.paddingLeft="5px",e.marginBottom="30px",e.boxShadow="0px 1px 10px rgba(0, 0, 0, 0.65)";const n=document.createElement("h1");n.textContent="ff-net",t.appendChild(n);const s=document.createElement("h2");s.textContent="feedforward neural network learning in real time",t.appendChild(s)}(),window.initData=P;const t=new D(P);document.body.appendChild(t.domElement),window.app=t}export{A as default};
